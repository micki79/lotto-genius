<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üçÄ LottoGenius - KI Lotto Analyse</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #6c5ce7;
            --primary-dark: #5b4cdb;
            --secondary: #00cec9;
            --accent: #fd79a8;
            --gold: #ffeaa7;
            --gold-dark: #fdcb6e;
            --bg-dark: #0f0f1a;
            --bg-card: #1a1a2e;
            --bg-card-hover: #242444;
            --text-primary: #ffffff;
            --text-secondary: #a0a0c0;
            --success: #00b894;
            --warning: #e17055;
            --gradient-1: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);
            --gradient-2: linear-gradient(135deg, #00cec9 0%, #81ecec 100%);
            --gradient-3: linear-gradient(135deg, #fd79a8 0%, #fab1a0 100%);
            --gradient-gold: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            --shadow-glow: 0 0 40px rgba(108, 92, 231, 0.3);
            --shadow-card: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Animated Background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .bg-animation::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(108, 92, 231, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(0, 206, 201, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 40% 60%, rgba(253, 121, 168, 0.08) 0%, transparent 50%);
            animation: bgMove 20s ease-in-out infinite;
        }

        @keyframes bgMove {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(2%, 2%) rotate(1deg); }
            50% { transform: translate(-1%, 3%) rotate(-1deg); }
            75% { transform: translate(3%, -2%) rotate(2deg); }
        }

        /* Floating Lotto Balls Background */
        .floating-balls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            overflow: hidden;
        }

        .floating-ball {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--gradient-1);
            opacity: 0.1;
            animation: float 15s infinite ease-in-out;
        }

        .floating-ball:nth-child(2) { left: 20%; animation-delay: -2s; background: var(--gradient-2); }
        .floating-ball:nth-child(3) { left: 40%; animation-delay: -4s; background: var(--gradient-3); }
        .floating-ball:nth-child(4) { left: 60%; animation-delay: -6s; background: var(--gradient-gold); }
        .floating-ball:nth-child(5) { left: 80%; animation-delay: -8s; background: var(--gradient-1); }

        @keyframes float {
            0%, 100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.1; }
            90% { opacity: 0.1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        /* Header */
        .header {
            background: linear-gradient(180deg, var(--bg-card) 0%, transparent 100%);
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(20px);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 50px;
            height: 50px;
            background: var(--gradient-gold);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: 0 5px 20px rgba(253, 203, 110, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .logo-text {
            font-size: 24px;
            font-weight: 800;
            background: var(--gradient-gold);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo-subtitle {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .next-draw {
            text-align: right;
        }

        .next-draw-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .next-draw-date {
            font-family: 'Space Mono', monospace;
            font-size: 18px;
            color: var(--secondary);
            font-weight: 700;
        }

        .countdown {
            font-family: 'Space Mono', monospace;
            font-size: 13px;
            color: var(--accent);
        }

        /* Main Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            overflow-x: auto;
            padding-bottom: 10px;
            scrollbar-width: none;
        }

        .nav-tabs::-webkit-scrollbar {
            display: none;
        }

        .nav-tab {
            padding: 14px 28px;
            background: var(--bg-card);
            border: 2px solid transparent;
            border-radius: 50px;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-tab:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
        }

        .nav-tab.active {
            background: var(--gradient-1);
            color: white;
            border-color: transparent;
            box-shadow: var(--shadow-glow);
        }

        .nav-tab .icon {
            font-size: 18px;
        }

        /* Tab Panels */
        .tab-panel {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .tab-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: 24px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-card);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .card-title {
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .card-title .icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .card-title .icon.purple { background: var(--gradient-1); }
        .card-title .icon.teal { background: var(--gradient-2); }
        .card-title .icon.pink { background: var(--gradient-3); }
        .card-title .icon.gold { background: var(--gradient-gold); color: #333; }

        /* Lotto Balls */
        .lotto-balls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        .lotto-ball {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-size: 22px;
            font-weight: 700;
            color: white;
            background: var(--gradient-1);
            box-shadow: 
                0 10px 30px rgba(108, 92, 231, 0.4),
                inset 0 -5px 20px rgba(0, 0, 0, 0.2),
                inset 0 5px 20px rgba(255, 255, 255, 0.2);
            position: relative;
            animation: ballPop 0.5s ease;
        }

        .lotto-ball::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 12px;
            width: 15px;
            height: 10px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            transform: rotate(-30deg);
        }

        .lotto-ball.superzahl {
            background: var(--gradient-gold);
            color: #333;
            box-shadow: 
                0 10px 30px rgba(253, 203, 110, 0.4),
                inset 0 -5px 20px rgba(0, 0, 0, 0.1),
                inset 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .lotto-ball.small {
            width: 45px;
            height: 45px;
            font-size: 16px;
        }

        @keyframes ballPop {
            0% { transform: scale(0); }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* KI Prediction Section */
        .prediction-container {
            display: grid;
            gap: 20px;
        }

        .prediction-card {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-card-hover) 100%);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(108, 92, 231, 0.2);
            position: relative;
            overflow: hidden;
        }

        .prediction-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--gradient-1);
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .prediction-rank {
            font-family: 'Space Mono', monospace;
            font-size: 14px;
            color: var(--secondary);
            background: rgba(0, 206, 201, 0.1);
            padding: 6px 14px;
            border-radius: 20px;
        }

        .prediction-confidence {
            font-family: 'Space Mono', monospace;
            font-size: 18px;
            font-weight: 700;
            color: var(--gold);
        }

        /* Progress Bars */
        .progress-container {
            margin-top: 15px;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 1s ease;
        }

        .progress-fill.purple { background: var(--gradient-1); }
        .progress-fill.teal { background: var(--gradient-2); }
        .progress-fill.pink { background: var(--gradient-3); }
        .progress-fill.gold { background: var(--gradient-gold); }

        /* Statistics Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .stat-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .stat-icon.purple { background: var(--gradient-1); }
        .stat-icon.teal { background: var(--gradient-2); }
        .stat-icon.pink { background: var(--gradient-3); }
        .stat-icon.gold { background: var(--gradient-gold); color: #333; }

        .stat-value {
            font-family: 'Space Mono', monospace;
            font-size: 28px;
            font-weight: 700;
        }

        .stat-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Frequency Chart */
        .frequency-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .freq-item {
            text-align: center;
            padding: 15px 5px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .freq-item:hover {
            background: rgba(108, 92, 231, 0.2);
            transform: scale(1.05);
        }

        .freq-item.hot {
            background: rgba(253, 121, 168, 0.2);
            border: 1px solid rgba(253, 121, 168, 0.3);
        }

        .freq-item.cold {
            background: rgba(0, 206, 201, 0.2);
            border: 1px solid rgba(0, 206, 201, 0.3);
        }

        .freq-number {
            font-family: 'Space Mono', monospace;
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .freq-count {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .freq-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .freq-bar-fill {
            height: 100%;
            background: var(--gradient-1);
            border-radius: 2px;
            transition: width 1s ease;
        }

        /* Buttons */
        .btn {
            padding: 16px 32px;
            border: none;
            border-radius: 50px;
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn-primary {
            background: var(--gradient-1);
            color: white;
            box-shadow: 0 10px 30px rgba(108, 92, 231, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(108, 92, 231, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-gold {
            background: var(--gradient-gold);
            color: #333;
            box-shadow: 0 10px 30px rgba(253, 203, 110, 0.3);
        }

        .btn-gold:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(253, 203, 110, 0.4);
        }

        /* Action Buttons Row */
        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 25px;
        }

        /* Loading Spinner */
        .loader {
            display: none;
            justify-content: center;
            align-items: center;
            padding: 60px;
        }

        .loader.active {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(108, 92, 231, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* History Table */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .history-table th,
        .history-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .history-table th {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .history-table tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .history-date {
            font-family: 'Space Mono', monospace;
            color: var(--secondary);
        }

        .history-balls {
            display: flex;
            gap: 6px;
        }

        .history-ball {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            background: var(--gradient-1);
            color: white;
        }

        .history-ball.sz {
            background: var(--gradient-gold);
            color: #333;
        }

        /* AI Chat Section */
        .ai-section {
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.1) 0%, rgba(0, 206, 201, 0.1) 100%);
            border-radius: 24px;
            padding: 30px;
            border: 1px solid rgba(108, 92, 231, 0.2);
            margin-top: 30px;
        }

        .ai-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .ai-avatar {
            width: 60px;
            height: 60px;
            background: var(--gradient-1);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: var(--shadow-glow);
        }

        .ai-title {
            font-size: 22px;
            font-weight: 700;
        }

        .ai-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .ai-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--success);
            background: rgba(0, 184, 148, 0.1);
            padding: 6px 14px;
            border-radius: 20px;
            margin-top: 5px;
        }

        .ai-status-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .ai-message {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            margin-top: 15px;
            line-height: 1.7;
            color: var(--text-secondary);
        }

        .ai-message strong {
            color: var(--text-primary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .next-draw {
                text-align: center;
            }

            .logo-text {
                font-size: 20px;
            }

            .card {
                padding: 20px;
            }

            .lotto-ball {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            .frequency-grid {
                grid-template-columns: repeat(5, 1fr);
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }

            .history-table {
                font-size: 14px;
            }

            .history-table th,
            .history-table td {
                padding: 10px;
            }
        }

        /* Notification Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-card);
            color: white;
            padding: 16px 28px;
            border-radius: 50px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 1000;
            transition: transform 0.3s ease;
            border: 1px solid rgba(108, 92, 231, 0.3);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast-icon {
            font-size: 20px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }

        .empty-state-title {
            font-size: 20px;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        /* Superzahl Analysis Card */
        .superzahl-analysis-card {
            background: linear-gradient(135deg, rgba(255, 234, 167, 0.1) 0%, rgba(253, 203, 110, 0.15) 100%);
            border: 2px solid rgba(253, 203, 110, 0.4);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .sz-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .sz-icon {
            font-size: 36px;
            filter: drop-shadow(0 0 10px rgba(253, 203, 110, 0.5));
        }

        .sz-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--gold);
        }

        .sz-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .sz-best {
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .sz-best-number {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: var(--gradient-gold);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-size: 32px;
            font-weight: 700;
            color: #333;
            box-shadow: 
                0 10px 30px rgba(253, 203, 110, 0.4),
                inset 0 -5px 20px rgba(0, 0, 0, 0.1),
                inset 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .sz-best-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .sz-best-prob {
            font-family: 'Space Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: var(--gold);
        }

        .sz-alternatives {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .sz-alt-title {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .sz-alt-list {
            display: flex;
            gap: 10px;
        }

        .sz-alt-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 14px;
            border-radius: 20px;
        }

        .sz-alt-num {
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            color: var(--text-primary);
        }

        .sz-alt-prob {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .lotto-ball.superzahl.optimized {
            box-shadow: 
                0 10px 30px rgba(253, 203, 110, 0.5),
                0 0 20px rgba(253, 203, 110, 0.3),
                inset 0 -5px 20px rgba(0, 0, 0, 0.1),
                inset 0 5px 20px rgba(255, 255, 255, 0.3);
            animation: szGlow 2s infinite;
        }

        @keyframes szGlow {
            0%, 100% { box-shadow: 0 10px 30px rgba(253, 203, 110, 0.4), 0 0 20px rgba(253, 203, 110, 0.2); }
            50% { box-shadow: 0 10px 30px rgba(253, 203, 110, 0.6), 0 0 30px rgba(253, 203, 110, 0.4); }
        }

        /* Ensemble Card Styling */
        .ensemble-header {
            background: linear-gradient(135deg, rgba(255, 234, 167, 0.15) 0%, rgba(253, 203, 110, 0.15) 100%);
            border: 2px solid rgba(253, 203, 110, 0.3);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 25px;
            text-align: center;
        }

        .ensemble-title {
            font-size: 22px;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .ensemble-stats {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        .multi-ki-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .ki-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }

        .ki-chip.loading {
            background: rgba(108, 92, 231, 0.2);
            color: var(--primary);
            animation: pulse 1.5s infinite;
        }

        .ki-chip.success {
            background: rgba(0, 184, 148, 0.2);
            color: var(--success);
        }

        .ki-chip.error {
            background: rgba(225, 112, 85, 0.2);
            color: var(--warning);
        }

        .ensemble-card {
            border: 2px solid rgba(253, 203, 110, 0.3) !important;
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(253, 203, 110, 0.05) 100%) !important;
        }

        .ensemble-card::before {
            background: var(--gradient-gold) !important;
        }

        /* Settings Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(10px);
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border-radius: 24px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 22px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .api-key-item {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .api-key-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .api-key-name {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .api-key-name .icon {
            font-size: 20px;
        }

        .api-key-status {
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 20px;
        }

        .api-key-status.active {
            background: rgba(0, 184, 148, 0.2);
            color: var(--success);
        }

        .api-key-status.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .api-key-description {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .api-key-input {
            display: flex;
            gap: 10px;
        }

        .api-key-input input {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            color: white;
            font-family: 'Space Mono', monospace;
            font-size: 13px;
        }

        .api-key-input input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .api-key-input input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        .btn-save-key {
            padding: 12px 20px;
            background: var(--gradient-1);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-save-key:hover {
            transform: scale(1.05);
        }

        .api-link {
            display: inline-block;
            margin-top: 8px;
            font-size: 12px;
            color: var(--secondary);
            text-decoration: none;
        }

        .api-link:hover {
            text-decoration: underline;
        }

        /* Settings Button */
        .settings-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--gradient-1);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(108, 92, 231, 0.4);
            transition: all 0.3s ease;
            z-index: 100;
        }

        .settings-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(108, 92, 231, 0.5);
        }

        /* Disclaimer */
        .disclaimer {
            background: rgba(225, 112, 85, 0.1);
            border: 1px solid rgba(225, 112, 85, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            margin-top: 20px;
            font-size: 13px;
            color: var(--warning);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .disclaimer-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        /* Install PWA Banner */
        .install-banner {
            display: none;
            background: var(--gradient-1);
            padding: 15px 20px;
            border-radius: 16px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .install-banner.show {
            display: flex;
        }

        .install-text {
            font-size: 14px;
        }

        .install-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .install-close:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="bg-animation"></div>
    <div class="floating-balls">
        <div class="floating-ball"></div>
        <div class="floating-ball"></div>
        <div class="floating-ball"></div>
        <div class="floating-ball"></div>
        <div class="floating-ball"></div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">üçÄ</div>
                <div>
                    <div class="logo-text">LottoGenius</div>
                    <div class="logo-subtitle">KI-Powered Analyse</div>
                </div>
            </div>
            <div class="next-draw">
                <div class="next-draw-label">N√§chste Ziehung</div>
                <div class="next-draw-date" id="nextDrawDate">--</div>
                <div class="countdown" id="countdown">--:--:--</div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Install PWA Banner -->
        <div class="install-banner" id="installBanner">
            <span class="install-text">üì± Installiere die App auf deinem Handy f√ºr den besten Zugriff!</span>
            <button class="btn btn-secondary" id="installBtn" style="padding: 10px 20px;">Installieren</button>
            <button class="install-close" id="closeBanner">√ó</button>
        </div>

        <!-- Navigation Tabs -->
        <nav class="nav-tabs">
            <button class="nav-tab active" data-tab="predictions">
                <span class="icon">üéØ</span>
                <span>KI-Tipps</span>
            </button>
            <button class="nav-tab" data-tab="statistics">
                <span class="icon">üìä</span>
                <span>Statistiken</span>
            </button>
            <button class="nav-tab" data-tab="frequency">
                <span class="icon">üî•</span>
                <span>H√§ufigkeit</span>
            </button>
            <button class="nav-tab" data-tab="history">
                <span class="icon">üìú</span>
                <span>Historie</span>
            </button>
            <button class="nav-tab" data-tab="analysis">
                <span class="icon">üß†</span>
                <span>KI-Analyse</span>
            </button>
        </nav>

        <!-- Loading Spinner -->
        <div class="loader" id="loader">
            <div class="spinner"></div>
        </div>

        <!-- Tab Panels -->
        
        <!-- Predictions Panel -->
        <div class="tab-panel active" id="predictions-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon gold">üéØ</span>
                        KI-Vorhersagen f√ºr die n√§chste Ziehung
                    </div>
                </div>
                
                <div class="ai-section">
                    <div class="ai-header">
                        <div class="ai-avatar">ü§ñ</div>
                        <div>
                            <div class="ai-title">LottoGenius KI</div>
                            <div class="ai-subtitle">Neuronales Netzwerk f√ºr Musteranalyse</div>
                            <div class="ai-status">
                                <span class="ai-status-dot"></span>
                                Aktiv & Lernt kontinuierlich
                            </div>
                        </div>
                    </div>
                    <div class="ai-message" id="aiMessage">
                        Initialisiere KI-Analyse... Bitte warten Sie, w√§hrend die historischen Daten geladen und analysiert werden.
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-primary" id="generatePredictions">
                        <span>üîÆ</span>
                        Neue Tipps generieren
                    </button>
                    <button class="btn btn-secondary" id="refreshData">
                        <span>üîÑ</span>
                        Daten aktualisieren
                    </button>
                </div>

                <div class="prediction-container" id="predictionsContainer" style="margin-top: 30px;">
                    <!-- Predictions will be inserted here -->
                </div>

                <div class="disclaimer">
                    <span class="disclaimer-icon">‚ö†Ô∏è</span>
                    <div>
                        <strong>Wichtiger Hinweis:</strong> Lotto ist ein Gl√ºcksspiel. Die KI-Analyse basiert auf historischen Mustern und statistischen Wahrscheinlichkeiten. Jede Ziehung ist unabh√§ngig und zuf√§llig. Spielen Sie verantwortungsvoll und nur mit Geld, das Sie sich leisten k√∂nnen zu verlieren.
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="tab-panel" id="statistics-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon purple">üìä</span>
                        √úbersicht Statistiken
                    </div>
                </div>
                
                <div class="stats-grid" id="statsGrid">
                    <!-- Stats will be inserted here -->
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon teal">üìà</span>
                        Letzte Ziehung
                    </div>
                    <span id="lastDrawDate" style="color: var(--text-secondary); font-family: 'Space Mono', monospace;">--</span>
                </div>
                
                <div class="lotto-balls" id="lastDrawBalls">
                    <!-- Last draw balls will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Frequency Panel -->
        <div class="tab-panel" id="frequency-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon pink">üî•</span>
                        Zahlen-H√§ufigkeit (Alle Ziehungen)
                    </div>
                </div>
                
                <div style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 16px; height: 16px; background: rgba(253, 121, 168, 0.5); border-radius: 4px;"></div>
                        <span style="font-size: 13px; color: var(--text-secondary);">Hei√üe Zahlen (oft gezogen)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 16px; height: 16px; background: rgba(0, 206, 201, 0.5); border-radius: 4px;"></div>
                        <span style="font-size: 13px; color: var(--text-secondary);">Kalte Zahlen (selten gezogen)</span>
                    </div>
                </div>

                <div class="frequency-grid" id="frequencyGrid">
                    <!-- Frequency items will be inserted here -->
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon gold">‚≠ê</span>
                        Superzahl-H√§ufigkeit
                    </div>
                </div>
                
                <div class="frequency-grid" id="superzahlGrid" style="grid-template-columns: repeat(5, 1fr);">
                    <!-- Superzahl frequency will be inserted here -->
                </div>
            </div>
        </div>

        <!-- History Panel -->
        <div class="tab-panel" id="history-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon teal">üìú</span>
                        Ziehungs-Historie
                    </div>
                </div>
                
                <div style="overflow-x: auto;">
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Datum</th>
                                <th>Gewinnzahlen</th>
                                <th>Superzahl</th>
                            </tr>
                        </thead>
                        <tbody id="historyTableBody">
                            <!-- History will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="action-buttons" style="justify-content: center;">
                    <button class="btn btn-secondary" id="loadMoreHistory">
                        Mehr laden
                    </button>
                </div>
            </div>
        </div>

        <!-- Analysis Panel -->
        <div class="tab-panel" id="analysis-panel">
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="icon purple">üß†</span>
                        KI Deep-Analyse
                    </div>
                </div>
                
                <div class="ai-section">
                    <div class="ai-header">
                        <div class="ai-avatar">üî¨</div>
                        <div>
                            <div class="ai-title">Erweiterte Musteranalyse</div>
                            <div class="ai-subtitle">Neuronales Netzwerk ‚Ä¢ Probabilistische Modelle</div>
                        </div>
                    </div>
                    <div class="ai-message" id="deepAnalysisMessage">
                        Klicke auf "Analyse starten" um eine tiefgehende KI-Analyse aller historischen Daten durchzuf√ºhren.
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-gold" id="startDeepAnalysis">
                        <span>üöÄ</span>
                        Deep-Analyse starten
                    </button>
                </div>

                <div id="analysisResults" style="margin-top: 30px;">
                    <!-- Analysis results will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <span class="toast-icon">‚úÖ</span>
        <span id="toastMessage">Daten erfolgreich geladen!</span>
    </div>

    <!-- Settings Button -->
    <button class="settings-btn" id="settingsBtn" title="KI-APIs konfigurieren">‚öôÔ∏è</button>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">
                    <span>‚öôÔ∏è</span>
                    Multi-KI Konfiguration
                </div>
                <button class="modal-close" id="closeModal">√ó</button>
            </div>
            
            <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                Konfiguriere kostenlose KI-APIs f√ºr bessere Ensemble-Vorhersagen. 
                Je mehr KIs aktiv sind, desto besser die Ergebnisse!
            </p>

            <div id="apiKeysList">
                <!-- API Keys werden hier dynamisch eingef√ºgt -->
            </div>

            <div class="disclaimer" style="margin-top: 20px;">
                <span class="disclaimer-icon">üí°</span>
                <div>
                    <strong>Tipp:</strong> Alle diese APIs haben gro√üz√ºgige kostenlose Tiers. 
                    Du brauchst keine Kreditkarte f√ºr die Basis-Nutzung!
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // LOTTOGENIUS - MAIN APPLICATION
        // ========================================

        // Global Variables
        let lottoData = [];
        let frequencyMap = {};
        let superzahlMap = {};
        let historyPage = 0;
        let deferredPrompt = null;

        // API Endpoint
        const API_URL = 'https://johannesfriedrich.github.io/LottoNumberArchive/Lottonumbers_tidy_complete.json';

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function showToast(message, icon = '‚úÖ') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            const toastIcon = toast.querySelector('.toast-icon');
            
            toastMessage.textContent = message;
            toastIcon.textContent = icon;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function showLoader(show = true) {
            document.getElementById('loader').classList.toggle('active', show);
        }

        function formatDate(dateStr) {
            const [day, month, year] = dateStr.split('.');
            const date = new Date(year, month - 1, day);
            return date.toLocaleDateString('de-DE', { 
                weekday: 'short', 
                day: '2-digit', 
                month: '2-digit', 
                year: 'numeric' 
            });
        }

        // ========================================
        // DATA FETCHING & PROCESSING
        // ========================================

        async function fetchLottoData() {
            showLoader(true);
            try {
                const response = await fetch(API_URL);
                if (!response.ok) throw new Error('Netzwerkfehler');
                
                const rawData = await response.json();
                processData(rawData);
                
                showToast('Daten erfolgreich geladen!', '‚úÖ');
                return true;
            } catch (error) {
                console.error('Fehler beim Laden:', error);
                showToast('Fehler beim Laden der Daten', '‚ùå');
                
                // Try loading from localStorage cache
                const cached = localStorage.getItem('lottoDataCache');
                if (cached) {
                    const { data, timestamp } = JSON.parse(cached);
                    if (Date.now() - timestamp < 7 * 24 * 60 * 60 * 1000) {
                        processData(data);
                        showToast('Cached Daten geladen', '‚ÑπÔ∏è');
                        return true;
                    }
                }
                return false;
            } finally {
                showLoader(false);
            }
        }

        function processData(rawData) {
            // Group by date
            const grouped = {};
            
            rawData.forEach(item => {
                if (!grouped[item.date]) {
                    grouped[item.date] = {
                        date: item.date,
                        numbers: [],
                        superzahl: null
                    };
                }
                
                if (item.variable === 'Lottozahl') {
                    grouped[item.date].numbers.push(parseInt(item.value));
                } else if (item.variable === 'Superzahl') {
                    grouped[item.date].superzahl = parseInt(item.value);
                }
            });

            // Convert to array and sort by date (newest first)
            lottoData = Object.values(grouped)
                .filter(d => d.numbers.length === 6 && d.superzahl !== null)
                .map(d => ({
                    ...d,
                    numbers: d.numbers.sort((a, b) => a - b)
                }))
                .sort((a, b) => {
                    const [dayA, monthA, yearA] = a.date.split('.').map(Number);
                    const [dayB, monthB, yearB] = b.date.split('.').map(Number);
                    return new Date(yearB, monthB - 1, dayB) - new Date(yearA, monthA - 1, dayA);
                });

            // Calculate frequencies
            frequencyMap = {};
            superzahlMap = {};
            
            for (let i = 1; i <= 49; i++) {
                frequencyMap[i] = 0;
            }
            for (let i = 0; i <= 9; i++) {
                superzahlMap[i] = 0;
            }

            lottoData.forEach(draw => {
                draw.numbers.forEach(num => {
                    frequencyMap[num]++;
                });
                superzahlMap[draw.superzahl]++;
            });

            // Cache the data
            try {
                localStorage.setItem('lottoDataCache', JSON.stringify({
                    data: rawData,
                    timestamp: Date.now()
                }));
            } catch (e) {
                console.log('Could not cache data');
            }

            // Update UI
            updateUI();
        }

        // ========================================
        // UI UPDATE FUNCTIONS
        // ========================================

        function updateUI() {
            updateNextDraw();
            updateStatistics();
            updateFrequencyGrid();
            updateHistory();
            
            // Analysiere Superzahl-Muster
            szAnalyzer.analyzePatterns(lottoData, superzahlMap);
            
            generatePredictions();
            updateAIMessage();
        }

        function updateNextDraw() {
            const now = new Date();
            let nextDraw = new Date(now);
            
            // Find next Wednesday or Saturday
            const dayOfWeek = now.getDay();
            let daysUntilDraw;
            
            if (dayOfWeek < 3) { // Before Wednesday
                daysUntilDraw = 3 - dayOfWeek;
            } else if (dayOfWeek === 3) { // Wednesday
                if (now.getHours() >= 18 && now.getMinutes() >= 25) {
                    daysUntilDraw = 3; // Next Saturday
                } else {
                    daysUntilDraw = 0;
                }
            } else if (dayOfWeek < 6) { // Thursday or Friday
                daysUntilDraw = 6 - dayOfWeek;
            } else { // Saturday
                if (now.getHours() >= 19 && now.getMinutes() >= 25) {
                    daysUntilDraw = 4; // Next Wednesday
                } else {
                    daysUntilDraw = 0;
                }
            }

            nextDraw.setDate(nextDraw.getDate() + daysUntilDraw);
            
            // Set draw time (18:25 for Wednesday, 19:25 for Saturday)
            const isWednesday = nextDraw.getDay() === 3;
            nextDraw.setHours(isWednesday ? 18 : 19, 25, 0, 0);

            const dayName = isWednesday ? 'Mittwoch' : 'Samstag';
            document.getElementById('nextDrawDate').textContent = 
                `${dayName}, ${nextDraw.toLocaleDateString('de-DE')}`;

            // Update countdown every second
            function updateCountdown() {
                const now = new Date();
                const diff = nextDraw - now;
                
                if (diff <= 0) {
                    document.getElementById('countdown').textContent = 'Ziehung l√§uft!';
                    return;
                }

                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                document.getElementById('countdown').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            updateCountdown();
            setInterval(updateCountdown, 1000);
        }

        function updateStatistics() {
            const totalDraws = lottoData.length;
            const oldestDate = lottoData.length > 0 ? lottoData[lottoData.length - 1].date : '--';
            const newestDate = lottoData.length > 0 ? lottoData[0].date : '--';
            
            // Find most and least frequent numbers
            const sortedFreq = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]);
            const hottestNumber = sortedFreq[0] ? sortedFreq[0][0] : '--';
            const coldestNumber = sortedFreq[sortedFreq.length - 1] ? sortedFreq[sortedFreq.length - 1][0] : '--';

            const statsHTML = `
                <div class="stat-item">
                    <div class="stat-icon purple">üìä</div>
                    <div>
                        <div class="stat-value">${totalDraws.toLocaleString()}</div>
                        <div class="stat-label">Gesamt Ziehungen</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon teal">üìÖ</div>
                    <div>
                        <div class="stat-value">${oldestDate}</div>
                        <div class="stat-label">Erste Ziehung</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon pink">üî•</div>
                    <div>
                        <div class="stat-value">${hottestNumber}</div>
                        <div class="stat-label">H√§ufigste Zahl (${frequencyMap[hottestNumber]}x)</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon gold">‚ùÑÔ∏è</div>
                    <div>
                        <div class="stat-value">${coldestNumber}</div>
                        <div class="stat-label">Seltenste Zahl (${frequencyMap[coldestNumber]}x)</div>
                    </div>
                </div>
            `;

            document.getElementById('statsGrid').innerHTML = statsHTML;

            // Update last draw
            if (lottoData.length > 0) {
                const lastDraw = lottoData[0];
                document.getElementById('lastDrawDate').textContent = formatDate(lastDraw.date);
                
                let ballsHTML = '';
                lastDraw.numbers.forEach((num, i) => {
                    ballsHTML += `<div class="lotto-ball" style="animation-delay: ${i * 0.1}s">${num}</div>`;
                });
                ballsHTML += `<div class="lotto-ball superzahl" style="animation-delay: 0.6s">${lastDraw.superzahl}</div>`;
                
                document.getElementById('lastDrawBalls').innerHTML = ballsHTML;
            }
        }

        function updateFrequencyGrid() {
            const maxFreq = Math.max(...Object.values(frequencyMap));
            const minFreq = Math.min(...Object.values(frequencyMap));
            const avgFreq = Object.values(frequencyMap).reduce((a, b) => a + b, 0) / 49;
            
            // Determine hot and cold thresholds
            const hotThreshold = avgFreq + (maxFreq - avgFreq) * 0.3;
            const coldThreshold = avgFreq - (avgFreq - minFreq) * 0.3;

            let freqHTML = '';
            for (let i = 1; i <= 49; i++) {
                const count = frequencyMap[i];
                const percentage = ((count / maxFreq) * 100).toFixed(0);
                const isHot = count >= hotThreshold;
                const isCold = count <= coldThreshold;
                const className = isHot ? 'hot' : (isCold ? 'cold' : '');
                
                freqHTML += `
                    <div class="freq-item ${className}" title="Zahl ${i}: ${count}x gezogen">
                        <div class="freq-number">${i}</div>
                        <div class="freq-count">${count}x</div>
                        <div class="freq-bar">
                            <div class="freq-bar-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            }
            document.getElementById('frequencyGrid').innerHTML = freqHTML;

            // Superzahl frequency
            const maxSZ = Math.max(...Object.values(superzahlMap));
            let szHTML = '';
            for (let i = 0; i <= 9; i++) {
                const count = superzahlMap[i];
                const percentage = ((count / maxSZ) * 100).toFixed(0);
                
                szHTML += `
                    <div class="freq-item" title="Superzahl ${i}: ${count}x gezogen">
                        <div class="freq-number">${i}</div>
                        <div class="freq-count">${count}x</div>
                        <div class="freq-bar">
                            <div class="freq-bar-fill gold" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            }
            document.getElementById('superzahlGrid').innerHTML = szHTML;
        }

        function updateHistory(loadMore = false) {
            const itemsPerPage = 20;
            const startIndex = loadMore ? historyPage * itemsPerPage : 0;
            const endIndex = startIndex + itemsPerPage;
            const draws = lottoData.slice(startIndex, endIndex);

            let historyHTML = '';
            draws.forEach(draw => {
                let ballsHTML = '';
                draw.numbers.forEach(num => {
                    ballsHTML += `<div class="history-ball">${num}</div>`;
                });
                
                historyHTML += `
                    <tr>
                        <td class="history-date">${formatDate(draw.date)}</td>
                        <td>
                            <div class="history-balls">${ballsHTML}</div>
                        </td>
                        <td>
                            <div class="history-ball sz">${draw.superzahl}</div>
                        </td>
                    </tr>
                `;
            });

            if (loadMore) {
                document.getElementById('historyTableBody').innerHTML += historyHTML;
            } else {
                document.getElementById('historyTableBody').innerHTML = historyHTML;
            }

            historyPage = loadMore ? historyPage + 1 : 1;
        }

        // ========================================
        // PERSISTENTE SPEICHERUNG - INDEXEDDB
        // ========================================
        
        // IndexedDB f√ºr zuverl√§ssige, persistente Speicherung
        class LottoDatabase {
            constructor() {
                this.dbName = 'LottoGeniusDB';
                this.dbVersion = 2;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        console.log('üì¶ Datenbank initialisiert');
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Store f√ºr Lern-Historie
                        if (!db.objectStoreNames.contains('learningHistory')) {
                            const store = db.createObjectStore('learningHistory', { keyPath: 'id', autoIncrement: true });
                            store.createIndex('date', 'date', { unique: false });
                            store.createIndex('source', 'source', { unique: false });
                        }
                        
                        // Store f√ºr KI-Provider Scores
                        if (!db.objectStoreNames.contains('providerScores')) {
                            db.createObjectStore('providerScores', { keyPath: 'provider' });
                        }
                        
                        // Store f√ºr Superzahl-Analyse
                        if (!db.objectStoreNames.contains('superzahlHistory')) {
                            const szStore = db.createObjectStore('superzahlHistory', { keyPath: 'id', autoIncrement: true });
                            szStore.createIndex('date', 'date', { unique: false });
                        }
                        
                        // Store f√ºr alle Vorhersagen
                        if (!db.objectStoreNames.contains('predictions')) {
                            const predStore = db.createObjectStore('predictions', { keyPath: 'id', autoIncrement: true });
                            predStore.createIndex('drawDate', 'drawDate', { unique: false });
                            predStore.createIndex('verified', 'verified', { unique: false });
                        }
                        
                        // Store f√ºr Einstellungen
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                        
                        // Store f√ºr gecachte Lotto-Daten
                        if (!db.objectStoreNames.contains('lottoCache')) {
                            db.createObjectStore('lottoCache', { keyPath: 'key' });
                        }
                        
                        console.log('üì¶ Datenbank-Schema erstellt');
                    };
                });
            }

            async save(storeName, data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(data);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async add(storeName, data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add(data);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async get(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAll(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async delete(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async clear(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async count(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // Globale Datenbank-Instanz
        const lottoDB = new LottoDatabase();

        // ========================================
        // INTELLIGENTE SUPERZAHL-ANALYSE
        // ========================================

        class SuperzahlAnalyzer {
            constructor() {
                this.history = [];
                this.patterns = {};
                this.predictions = [];
            }

            async loadHistory() {
                try {
                    this.history = await lottoDB.getAll('superzahlHistory') || [];
                } catch {
                    this.history = [];
                }
            }

            async saveHistory() {
                for (const entry of this.history.slice(-500)) {
                    await lottoDB.add('superzahlHistory', entry);
                }
            }

            // Analysiert Superzahl-Muster
            analyzePatterns(lottoData, superzahlMap) {
                const patterns = {
                    frequency: {},           // H√§ufigkeit jeder Superzahl
                    recentTrend: {},         // Trend der letzten 20 Ziehungen
                    dayOfWeek: {             // Unterschiede Mi vs Sa
                        wednesday: {},
                        saturday: {}
                    },
                    afterNumber: {},         // Welche SZ kommt nach welcher SZ
                    gaps: {},                // Wie lange seit letzter Ziehung
                    streaks: {},             // Serien (gleiche SZ mehrfach)
                    monthlyPattern: {}       // Monatliche Muster
                };

                // Initialisiere
                for (let i = 0; i <= 9; i++) {
                    patterns.frequency[i] = superzahlMap[i] || 0;
                    patterns.recentTrend[i] = 0;
                    patterns.dayOfWeek.wednesday[i] = 0;
                    patterns.dayOfWeek.saturday[i] = 0;
                    patterns.gaps[i] = 999;
                    patterns.streaks[i] = 0;
                }

                // Analysiere letzte 20 Ziehungen f√ºr Trend
                const recent20 = lottoData.slice(0, 20);
                recent20.forEach(draw => {
                    patterns.recentTrend[draw.superzahl]++;
                });

                // Analysiere Wochentag-Muster
                lottoData.slice(0, 200).forEach(draw => {
                    const [day, month, year] = draw.date.split('.').map(Number);
                    const date = new Date(year, month - 1, day);
                    const dayOfWeek = date.getDay();
                    
                    if (dayOfWeek === 3) { // Mittwoch
                        patterns.dayOfWeek.wednesday[draw.superzahl]++;
                    } else if (dayOfWeek === 6) { // Samstag
                        patterns.dayOfWeek.saturday[draw.superzahl]++;
                    }
                });

                // Berechne L√ºcken (wie viele Ziehungen seit letztem Auftreten)
                for (let i = 0; i <= 9; i++) {
                    for (let j = 0; j < lottoData.length; j++) {
                        if (lottoData[j].superzahl === i) {
                            patterns.gaps[i] = j;
                            break;
                        }
                    }
                }

                // Analysiere Folge-Muster (welche SZ kommt nach welcher)
                for (let i = 0; i < lottoData.length - 1; i++) {
                    const current = lottoData[i].superzahl;
                    const previous = lottoData[i + 1].superzahl;
                    const key = `${previous}->${current}`;
                    patterns.afterNumber[key] = (patterns.afterNumber[key] || 0) + 1;
                }

                // Berechne Serien
                let currentStreak = { number: null, count: 0 };
                for (const draw of lottoData.slice(0, 50)) {
                    if (draw.superzahl === currentStreak.number) {
                        currentStreak.count++;
                    } else {
                        if (currentStreak.number !== null) {
                            patterns.streaks[currentStreak.number] = Math.max(
                                patterns.streaks[currentStreak.number] || 0,
                                currentStreak.count
                            );
                        }
                        currentStreak = { number: draw.superzahl, count: 1 };
                    }
                }

                this.patterns = patterns;
                return patterns;
            }

            // Berechnet die beste Superzahl-Vorhersage
            predictBestSuperzahl(lottoData, isWednesday = null) {
                const patterns = this.patterns;
                const scores = {};
                
                // Bestimme Wochentag der n√§chsten Ziehung
                if (isWednesday === null) {
                    const now = new Date();
                    const day = now.getDay();
                    isWednesday = day < 3 || (day === 3 && now.getHours() < 18);
                }

                const lastSZ = lottoData[0]?.superzahl;

                for (let i = 0; i <= 9; i++) {
                    let score = 0;
                    
                    // 1. H√§ufigkeits-Score (20%)
                    const maxFreq = Math.max(...Object.values(patterns.frequency));
                    const freqScore = (patterns.frequency[i] / maxFreq) * 20;
                    score += freqScore;

                    // 2. Trend-Score - bevorzuge Zahlen im Aufw√§rtstrend (25%)
                    const avgRecent = Object.values(patterns.recentTrend).reduce((a, b) => a + b, 0) / 10;
                    const trendScore = ((patterns.recentTrend[i] - avgRecent) / avgRecent + 1) * 12.5;
                    score += Math.max(0, Math.min(25, trendScore));

                    // 3. Wochentag-Score (15%)
                    const dayPattern = isWednesday ? patterns.dayOfWeek.wednesday : patterns.dayOfWeek.saturday;
                    const maxDay = Math.max(...Object.values(dayPattern));
                    const dayScore = maxDay > 0 ? (dayPattern[i] / maxDay) * 15 : 7.5;
                    score += dayScore;

                    // 4. L√ºcken-Score - √ºberf√§llige Zahlen bevorzugen (20%)
                    const maxGap = Math.max(...Object.values(patterns.gaps).filter(g => g < 999));
                    const gapScore = patterns.gaps[i] < 999 ? (patterns.gaps[i] / maxGap) * 20 : 10;
                    score += gapScore;

                    // 5. Folge-Muster-Score (15%)
                    if (lastSZ !== undefined) {
                        const followKey = `${lastSZ}->${i}`;
                        const followCount = patterns.afterNumber[followKey] || 0;
                        const maxFollow = Math.max(...Object.values(patterns.afterNumber));
                        const followScore = maxFollow > 0 ? (followCount / maxFollow) * 15 : 7.5;
                        score += followScore;
                    } else {
                        score += 7.5;
                    }

                    // 6. Anti-Serien-Score - vermeide zu lange Serien (5%)
                    if (i === lastSZ) {
                        score -= 5; // Reduziere wenn gleiche Zahl wie letzte Ziehung
                    } else {
                        score += 5;
                    }

                    scores[i] = Math.round(score * 10) / 10;
                }

                // Sortiere nach Score
                const ranked = Object.entries(scores)
                    .sort((a, b) => b[1] - a[1])
                    .map(([num, score]) => ({
                        number: parseInt(num),
                        score: score,
                        probability: (score / 100 * 100).toFixed(1)
                    }));

                return {
                    best: ranked[0],
                    top3: ranked.slice(0, 3),
                    all: ranked,
                    patterns: patterns,
                    nextDrawDay: isWednesday ? 'Mittwoch' : 'Samstag'
                };
            }

            // Lernt aus vergangenen Vorhersagen
            async learn(predictedSZ, actualSZ, drawDate) {
                const entry = {
                    date: drawDate,
                    predicted: predictedSZ,
                    actual: actualSZ,
                    correct: predictedSZ === actualSZ,
                    timestamp: new Date().toISOString()
                };
                
                this.history.push(entry);
                
                try {
                    await lottoDB.add('superzahlHistory', entry);
                } catch (e) {
                    console.log('SZ History save error:', e);
                }
                
                return entry;
            }

            // Berechnet Erfolgsquote
            getAccuracy() {
                if (this.history.length === 0) return { rate: 0, correct: 0, total: 0 };
                
                const correct = this.history.filter(h => h.correct).length;
                return {
                    rate: ((correct / this.history.length) * 100).toFixed(1),
                    correct: correct,
                    total: this.history.length
                };
            }
        }

        // Globale Superzahl-Analyzer Instanz
        const szAnalyzer = new SuperzahlAnalyzer();

        // ========================================
        // MULTI-KI-SYSTEM - KOMBINIERT MEHRERE KIs
        // ========================================

        // Konfiguration f√ºr verschiedene kostenlose KI-Anbieter
        const AI_PROVIDERS = {
            // Google Gemini - Sehr gro√üz√ºgiges kostenloses Tier
            gemini: {
                name: 'Google Gemini',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions',
                model: 'gemini-2.0-flash',
                apiKeyStorage: 'gemini_api_key',
                free: true,
                description: 'Googles leistungsstarkes Modell',
                icon: 'üîÆ'
            },
            // Groq - Ultraschnelle Inferenz
            groq: {
                name: 'Groq (Ultraschnell)',
                endpoint: 'https://api.groq.com/openai/v1/chat/completions',
                model: 'llama-3.3-70b-versatile',
                apiKeyStorage: 'groq_api_key',
                free: true,
                description: '18x schneller als GPUs',
                icon: '‚ö°'
            },
            // HuggingFace - Tausende Modelle
            huggingface: {
                name: 'HuggingFace',
                endpoint: 'https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.3',
                model: 'Mistral-7B',
                apiKeyStorage: 'hf_api_key',
                free: true,
                description: 'Open-Source Modelle',
                icon: 'ü§ó'
            },
            // OpenRouter - Zugang zu 50+ Modellen
            openrouter: {
                name: 'OpenRouter',
                endpoint: 'https://openrouter.ai/api/v1/chat/completions',
                model: 'deepseek/deepseek-chat:free',
                apiKeyStorage: 'openrouter_api_key',
                free: true,
                description: 'Zugang zu vielen Modellen',
                icon: 'üåê'
            },
            // Together AI - $25 Startguthaben
            together: {
                name: 'Together AI',
                endpoint: 'https://api.together.xyz/v1/chat/completions',
                model: 'meta-llama/Llama-3.3-70B-Instruct-Turbo',
                apiKeyStorage: 'together_api_key',
                free: true,
                description: '$25 Gratis-Guthaben',
                icon: 'üöÄ'
            },
            // DeepSeek - Komplett kostenlos
            deepseek: {
                name: 'DeepSeek',
                endpoint: 'https://api.deepseek.com/v1/chat/completions',
                model: 'deepseek-chat',
                apiKeyStorage: 'deepseek_api_key',
                free: true,
                description: 'Leistungsstark & kostenlos',
                icon: 'üß†'
            },
            // Claude (Anthropic) - In Artifacts integriert
            claude: {
                name: 'Claude (Anthropic)',
                endpoint: 'https://api.anthropic.com/v1/messages',
                model: 'claude-sonnet-4-20250514',
                apiKeyStorage: null, // Automatisch in Artifacts
                free: true,
                description: 'Premium KI von Anthropic',
                icon: 'ü§ñ'
            }
        };

        // Multi-KI-Agent Klasse
        class MultiKIAgent {
            constructor() {
                this.providers = AI_PROVIDERS;
                this.results = {};
                this.providerScores = {};
                this.apiKeys = {};
                this.lastEnsembleResult = null;
                this.initialized = false;
            }

            async init() {
                await this.loadProviderScores();
                this.loadApiKeys();
                this.initialized = true;
            }

            async loadProviderScores() {
                try {
                    const scores = await lottoDB.getAll('providerScores');
                    scores.forEach(s => {
                        this.providerScores[s.provider] = s;
                    });
                } catch {
                    // Fallback zu localStorage
                    try {
                        this.providerScores = JSON.parse(localStorage.getItem('multi_ki_scores')) || {};
                    } catch {
                        this.providerScores = {};
                    }
                }
            }

            async saveProviderScores() {
                try {
                    for (const [provider, data] of Object.entries(this.providerScores)) {
                        await lottoDB.save('providerScores', { provider, ...data });
                    }
                } catch {
                    // Fallback zu localStorage
                    localStorage.setItem('multi_ki_scores', JSON.stringify(this.providerScores));
                }
            }

            loadApiKeys() {
                const keys = {};
                Object.keys(this.providers).forEach(provider => {
                    const storageKey = this.providers[provider].apiKeyStorage;
                    if (storageKey) {
                        keys[provider] = localStorage.getItem(storageKey) || '';
                    }
                });
                this.apiKeys = keys;
                return keys;
            }

            saveApiKey(provider, key) {
                const storageKey = this.providers[provider].apiKeyStorage;
                if (storageKey) {
                    localStorage.setItem(storageKey, key);
                    this.apiKeys[provider] = key;
                }
            }

            getActiveProviders() {
                return Object.keys(this.providers).filter(p => 
                    p === 'claude' || this.apiKeys[p]
                );
            }

            // Ruft eine einzelne KI ab
            async callProvider(providerName, prompt) {
                const provider = this.providers[providerName];
                if (!provider) return null;

                const apiKey = this.apiKeys[providerName];
                
                try {
                    let response, data;

                    if (providerName === 'claude') {
                        // Claude API (in Artifacts integriert)
                        response = await fetch(provider.endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: provider.model,
                                max_tokens: 2000,
                                messages: [{ role: 'user', content: prompt }]
                            })
                        });
                        data = await response.json();
                        return data.content?.[0]?.text || null;
                    } 
                    else if (providerName === 'huggingface') {
                        // HuggingFace hat andere API-Struktur
                        response = await fetch(provider.endpoint, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                inputs: prompt,
                                parameters: { max_new_tokens: 1500 }
                            })
                        });
                        data = await response.json();
                        return data[0]?.generated_text || null;
                    }
                    else {
                        // OpenAI-kompatible APIs (Groq, OpenRouter, Together, Gemini, DeepSeek)
                        const headers = {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        };

                        // OpenRouter ben√∂tigt zus√§tzliche Header
                        if (providerName === 'openrouter') {
                            headers['HTTP-Referer'] = window.location.href;
                            headers['X-Title'] = 'LottoGenius';
                        }

                        response = await fetch(provider.endpoint, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify({
                                model: provider.model,
                                messages: [{ role: 'user', content: prompt }],
                                max_tokens: 2000,
                                temperature: 0.7
                            })
                        });
                        data = await response.json();
                        return data.choices?.[0]?.message?.content || null;
                    }
                } catch (error) {
                    console.log(`${providerName} Fehler:`, error.message);
                    return null;
                }
            }

            // Ruft ALLE aktiven KIs parallel ab
            async callAllProviders(prompt) {
                const activeProviders = this.getActiveProviders();
                const results = {};

                const promises = activeProviders.map(async (providerName) => {
                    const startTime = Date.now();
                    const result = await this.callProvider(providerName, prompt);
                    const duration = Date.now() - startTime;
                    
                    return {
                        provider: providerName,
                        result: result,
                        duration: duration,
                        success: !!result
                    };
                });

                const responses = await Promise.allSettled(promises);
                
                responses.forEach((response, index) => {
                    if (response.status === 'fulfilled' && response.value.success) {
                        results[response.value.provider] = response.value;
                    }
                });

                this.results = results;
                return results;
            }

            // Kombiniert die Ergebnisse aller KIs zu einem Ensemble
            combineResults(results, frequencyMap) {
                const allPredictions = [];
                const allNumbers = {};
                const allSuperzahlen = {};

                Object.entries(results).forEach(([provider, data]) => {
                    if (!data.result) return;

                    try {
                        // Versuche JSON aus der Antwort zu extrahieren
                        const jsonMatch = data.result.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const parsed = JSON.parse(jsonMatch[0]);
                            if (parsed.predictions) {
                                parsed.predictions.forEach(pred => {
                                    allPredictions.push({
                                        ...pred,
                                        source: provider
                                    });
                                    // Z√§hle Zahlen f√ºr Voting
                                    pred.numbers.forEach(n => {
                                        allNumbers[n] = (allNumbers[n] || 0) + 1;
                                    });
                                    allSuperzahlen[pred.superzahl] = (allSuperzahlen[pred.superzahl] || 0) + 1;
                                });
                            }
                        }
                    } catch (e) {
                        console.log(`Parsing Fehler f√ºr ${provider}:`, e.message);
                    }
                });

                // ========================================
                // INTELLIGENTE SUPERZAHL-BERECHNUNG
                // ========================================
                
                // Nutze den SuperzahlAnalyzer f√ºr beste Vorhersage
                const szAnalysis = szAnalyzer.predictBestSuperzahl(lottoData);
                const bestSuperzahl = szAnalysis.best.number;
                
                // Kombiniere KI-Voting mit statistischer Analyse
                const finalSuperzahlScores = {};
                for (let i = 0; i <= 9; i++) {
                    // 40% KI-Voting + 60% Statistische Analyse
                    const kiVotes = allSuperzahlen[i] || 0;
                    const maxKiVotes = Math.max(...Object.values(allSuperzahlen), 1);
                    const kiScore = (kiVotes / maxKiVotes) * 40;
                    
                    const statScore = szAnalysis.all.find(s => s.number === i)?.score || 0;
                    const statScoreNorm = (statScore / 100) * 60;
                    
                    finalSuperzahlScores[i] = kiScore + statScoreNorm;
                }
                
                // Beste Superzahl basierend auf kombinierter Analyse
                const rankedSuperzahlen = Object.entries(finalSuperzahlScores)
                    .sort((a, b) => b[1] - a[1])
                    .map(([num, score]) => ({
                        number: parseInt(num),
                        score: score.toFixed(1),
                        probability: (score).toFixed(1)
                    }));
                
                const optimalSuperzahl = rankedSuperzahlen[0]?.number ?? Math.floor(Math.random() * 10);

                // Ensemble-Voting: Zahlen die von mehreren KIs gew√§hlt wurden
                const votedNumbers = Object.entries(allNumbers)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 15)
                    .map(([n]) => parseInt(n));

                // Generiere Ensemble-Tipps
                const ensemblePredictions = [];
                
                // Tipp 1: Nur Zahlen die von ALLEN KIs gew√§hlt wurden + optimale Superzahl
                const unanimousNumbers = Object.entries(allNumbers)
                    .filter(([n, count]) => count >= Object.keys(results).length)
                    .map(([n]) => parseInt(n));
                
                if (unanimousNumbers.length >= 3) {
                    const tip1 = [...unanimousNumbers.slice(0, 6)];
                    while (tip1.length < 6) {
                        const next = votedNumbers.find(n => !tip1.includes(n));
                        if (next) tip1.push(next);
                    }
                    ensemblePredictions.push({
                        numbers: tip1.sort((a, b) => a - b),
                        superzahl: optimalSuperzahl,
                        confidence: 95,
                        strategy: 'üèÜ ENSEMBLE CHAMPION - Einstimmige KI-Wahl + Optimale Superzahl',
                        reasoning: `Alle ${Object.keys(results).length} KIs + Superzahl ${optimalSuperzahl} (${rankedSuperzahlen[0]?.probability ?? '?'}% Wahrscheinlichkeit)`,
                        isEnsemble: true,
                        superzahlAnalysis: rankedSuperzahlen.slice(0, 3)
                    });
                }

                // Tipp 2-4: Mehrheitsentscheidungen mit verschiedenen Top-Superzahlen
                for (let threshold = Math.max(2, Object.keys(results).length - 1); threshold >= 2; threshold--) {
                    if (ensemblePredictions.length >= 3) break;
                    
                    const majorityNumbers = Object.entries(allNumbers)
                        .filter(([n, count]) => count >= threshold)
                        .map(([n]) => parseInt(n));
                    
                    if (majorityNumbers.length >= 6) {
                        const tipNumbers = majorityNumbers
                            .sort(() => Math.random() - 0.5)
                            .slice(0, 6)
                            .sort((a, b) => a - b);
                        
                        // Nutze die n√§chstbeste Superzahl
                        const szIndex = rankedSuperzahlen.length > 0 ? Math.min(ensemblePredictions.length, rankedSuperzahlen.length - 1) : 0;
                        const tipSuperzahl = rankedSuperzahlen[szIndex]?.number ?? Math.floor(Math.random() * 10);
                        
                        ensemblePredictions.push({
                            numbers: tipNumbers,
                            superzahl: tipSuperzahl,
                            confidence: 70 + threshold * 5,
                            strategy: `ü§ù ENSEMBLE MEHRHEIT - ${threshold}+ KI Stimmen`,
                            reasoning: `Mindestens ${threshold} KIs + Superzahl ${tipSuperzahl} (Top ${szIndex + 1})`,
                            isEnsemble: true,
                            superzahlAnalysis: rankedSuperzahlen.slice(0, 3)
                        });
                    }
                }

                // F√ºge die besten individuellen Vorhersagen hinzu (mit optimierter Superzahl)
                const sortedIndividual = allPredictions
                    .sort((a, b) => (b.confidence || 50) - (a.confidence || 50))
                    .slice(0, 10 - ensemblePredictions.length)
                    .map((pred, i) => ({
                        ...pred,
                        // Ersetze Superzahl mit statistisch bester
                        superzahl: rankedSuperzahlen.length > 0 ? (rankedSuperzahlen[Math.min(i, rankedSuperzahlen.length - 1)]?.number ?? pred.superzahl) : pred.superzahl,
                        strategy: `${this.providers[pred.source]?.icon || 'ü§ñ'} ${this.providers[pred.source]?.name || pred.source}: ${pred.strategy}`,
                        isEnsemble: false,
                        superzahlOptimized: true
                    }));

                const finalPredictions = [
                    ...ensemblePredictions,
                    ...sortedIndividual
                ].slice(0, 10);

                this.lastEnsembleResult = {
                    predictions: finalPredictions,
                    votingStats: {
                        totalVotes: allNumbers,
                        superzahlVotes: allSuperzahlen,
                        providersUsed: Object.keys(results).length,
                        superzahlAnalysis: {
                            best: rankedSuperzahlen[0],
                            top3: rankedSuperzahlen.slice(0, 3),
                            all: rankedSuperzahlen,
                            patterns: szAnalysis.patterns,
                            nextDrawDay: szAnalysis.nextDrawDay
                        }
                    },
                    analysis: `${Object.keys(results).length} KI-Systeme haben ${allPredictions.length} Vorhersagen generiert. Optimale Superzahl: ${optimalSuperzahl} (${rankedSuperzahlen[0]?.probability ?? '?'}%)`
                };

                return this.lastEnsembleResult;
            }

            // Lernt welche KI am besten ist
            async learnFromResults(actualNumbers, predictions) {
                for (const pred of predictions) {
                    if (!pred.source) continue;
                    
                    const matches = pred.numbers.filter(n => actualNumbers.includes(n)).length;
                    const szMatch = pred.superzahl === actualNumbers[6];
                    
                    if (!this.providerScores[pred.source]) {
                        this.providerScores[pred.source] = { 
                            total: 0, 
                            matches: 0, 
                            predictions: 0,
                            szCorrect: 0 
                        };
                    }
                    
                    this.providerScores[pred.source].predictions++;
                    this.providerScores[pred.source].matches += matches;
                    this.providerScores[pred.source].total += 6;
                    if (szMatch) this.providerScores[pred.source].szCorrect++;
                }

                await this.saveProviderScores();
            }

            getProviderRankings() {
                return Object.entries(this.providerScores)
                    .map(([provider, stats]) => ({
                        provider,
                        name: this.providers[provider]?.name || provider,
                        icon: this.providers[provider]?.icon || 'ü§ñ',
                        accuracy: stats.total > 0 ? ((stats.matches / stats.total) * 100).toFixed(1) : 0,
                        szAccuracy: stats.predictions > 0 ? ((stats.szCorrect / stats.predictions) * 100).toFixed(1) : 0,
                        predictions: stats.predictions
                    }))
                    .sort((a, b) => parseFloat(b.accuracy) - parseFloat(a.accuracy));
            }
        }

        // Globale Multi-KI-Agent Instanz
        const multiKI = new MultiKIAgent();

        // ========================================
        // ECHTE KI-INTEGRATION MIT CLAUDE API
        // ========================================

        // KI-Agent Klasse f√ºr kontinuierliches Lernen
        class LottoKIAgent {
            constructor() {
                this.learningHistory = [];
                this.predictionAccuracy = { correct: 0, total: 0, details: [] };
                this.modelVersion = '3.0-MultiKI';
                this.lastAnalysis = null;
                this.initialized = false;
            }

            async init() {
                await this.loadLearningHistory();
                await this.loadAccuracy();
                this.initialized = true;
            }

            async loadLearningHistory() {
                try {
                    this.learningHistory = await lottoDB.getAll('learningHistory') || [];
                } catch {
                    try {
                        this.learningHistory = JSON.parse(localStorage.getItem('ki_learning_history')) || [];
                    } catch {
                        this.learningHistory = [];
                    }
                }
            }

            async loadAccuracy() {
                try {
                    const acc = await lottoDB.get('settings', 'accuracy');
                    this.predictionAccuracy = acc?.value || { correct: 0, total: 0, details: [] };
                } catch {
                    try {
                        this.predictionAccuracy = JSON.parse(localStorage.getItem('ki_accuracy')) || { correct: 0, total: 0, details: [] };
                    } catch {
                        this.predictionAccuracy = { correct: 0, total: 0, details: [] };
                    }
                }
            }

            async saveLearningHistory(entry) {
                try {
                    await lottoDB.add('learningHistory', entry);
                } catch {
                    localStorage.setItem('ki_learning_history', JSON.stringify(this.learningHistory.slice(-100)));
                }
            }

            async saveAccuracy() {
                try {
                    await lottoDB.save('settings', { key: 'accuracy', value: this.predictionAccuracy });
                } catch {
                    localStorage.setItem('ki_accuracy', JSON.stringify(this.predictionAccuracy));
                }
            }

            // Speichert Vorhersagen f√ºr sp√§tere √úberpr√ºfung
            async savePredictions(predictions, nextDrawDate) {
                const entry = {
                    drawDate: nextDrawDate,
                    predictions: predictions,
                    timestamp: new Date().toISOString(),
                    verified: false
                };
                
                try {
                    await lottoDB.add('predictions', entry);
                } catch (e) {
                    console.log('Prediction save error:', e);
                }
                
                return entry;
            }

            // Verifiziert Vorhersagen gegen echte Zahlen
            async verifyPredictions(actualNumbers, actualSuperzahl, drawDate) {
                try {
                    const allPredictions = await lottoDB.getAll('predictions');
                    const unverified = allPredictions.filter(p => !p.verified);
                    
                    for (const pred of unverified) {
                        // Markiere als verifiziert
                        pred.verified = true;
                        pred.actualNumbers = actualNumbers;
                        pred.actualSuperzahl = actualSuperzahl;
                        
                        // Berechne Treffer
                        pred.results = pred.predictions.map(p => ({
                            numbers: p.numbers,
                            matches: p.numbers.filter(n => actualNumbers.includes(n)).length,
                            szMatch: p.superzahl === actualSuperzahl,
                            source: p.source
                        }));
                        
                        await lottoDB.save('predictions', pred);
                        
                        // Lerne aus den Ergebnissen
                        await this.learnFromVerifiedPredictions(pred);
                    }
                } catch (e) {
                    console.log('Verify error:', e);
                }
            }

            // Lernt aus verifizierten Vorhersagen
            async learnFromVerifiedPredictions(pred) {
                for (const result of pred.results) {
                    const entry = {
                        date: pred.timestamp,
                        predicted: result.numbers,
                        actual: pred.actualNumbers,
                        matches: result.matches,
                        szMatch: result.szMatch,
                        source: result.source || 'local'
                    };
                    
                    this.learningHistory.push(entry);
                    await this.saveLearningHistory(entry);

                    this.predictionAccuracy.total++;
                    if (result.matches >= 3) this.predictionAccuracy.correct++;
                }
                
                await this.saveAccuracy();
                
                // Lerne auch im MultiKI
                if (pred.actualNumbers) {
                    await multiKI.learnFromResults(pred.actualNumbers, pred.predictions);
                }
            }

            // Lernt aus vergangenen Vorhersagen (manuelle Eingabe)
            async learnFromPastPredictions(actualNumbers, predictions) {
                for (const pred of predictions) {
                    const matches = pred.numbers.filter(n => actualNumbers.slice(0, 6).includes(n)).length;
                    const szMatch = pred.superzahl === actualNumbers[6];
                    
                    const entry = {
                        date: new Date().toISOString(),
                        predicted: pred.numbers,
                        actual: actualNumbers.slice(0, 6),
                        matches: matches,
                        szMatch: szMatch,
                        strategy: pred.strategy,
                        source: pred.source || 'local'
                    };
                    
                    this.learningHistory.push(entry);
                    await this.saveLearningHistory(entry);

                    this.predictionAccuracy.total++;
                    if (matches >= 3) this.predictionAccuracy.correct++;
                }

                await this.saveAccuracy();
                
                // Lerne auch im MultiKI
                await multiKI.learnFromResults(actualNumbers, predictions);
                
                // Lerne Superzahl
                if (predictions.length > 0 && actualNumbers[6] !== undefined) {
                    await szAnalyzer.learn(predictions[0].superzahl, actualNumbers[6], new Date().toISOString());
                }
            }

            // Berechnet welche Strategien am besten funktionieren
            getBestStrategies() {
                const strategyStats = {};
                
                this.learningHistory.forEach(entry => {
                    const strat = entry.strategy || entry.source || 'unknown';
                    if (!strategyStats[strat]) {
                        strategyStats[strat] = { matches: 0, count: 0, szCorrect: 0 };
                    }
                    strategyStats[strat].matches += entry.matches || 0;
                    strategyStats[strat].count++;
                    if (entry.szMatch) strategyStats[strat].szCorrect++;
                });

                return Object.entries(strategyStats)
                    .map(([strategy, stats]) => ({
                        strategy,
                        avgMatches: stats.count > 0 ? stats.matches / stats.count : 0,
                        szAccuracy: stats.count > 0 ? ((stats.szCorrect / stats.count) * 100).toFixed(1) : 0,
                        count: stats.count
                    }))
                    .sort((a, b) => b.avgMatches - a.avgMatches);
            }

            getAccuracyRate() {
                if (this.predictionAccuracy.total === 0) return 0;
                return ((this.predictionAccuracy.correct / this.predictionAccuracy.total) * 100).toFixed(1);
            }

            // Gibt Speicherstatistiken zur√ºck
            async getStorageStats() {
                try {
                    const learningCount = await lottoDB.count('learningHistory');
                    const predictionsCount = await lottoDB.count('predictions');
                    const szCount = await lottoDB.count('superzahlHistory');
                    
                    return {
                        learningEntries: learningCount,
                        predictions: predictionsCount,
                        superzahlHistory: szCount,
                        totalAccuracy: this.getAccuracyRate(),
                        modelVersion: this.modelVersion
                    };
                } catch {
                    return {
                        learningEntries: this.learningHistory.length,
                        predictions: 0,
                        superzahlHistory: 0,
                        totalAccuracy: this.getAccuracyRate(),
                        modelVersion: this.modelVersion
                    };
                }
            }
        }

        // Globale KI-Agent Instanz
        const kiAgent = new LottoKIAgent();

        // Erstelle den Prompt f√ºr alle KIs
        function createAnalysisPrompt(lottoData, frequencyMap, superzahlMap) {
            const recentDraws = lottoData.slice(0, 50);
            const sortedFreq = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]);
            const hotNumbers = sortedFreq.slice(0, 10).map(([n]) => parseInt(n));
            const coldNumbers = sortedFreq.slice(-10).map(([n]) => parseInt(n));
            
            // Berechne L√ºcken
            const gaps = {};
            for (let i = 1; i <= 49; i++) {
                let gap = 0;
                for (const draw of lottoData) {
                    if (draw.numbers.includes(i)) break;
                    gap++;
                }
                gaps[i] = gap;
            }
            const overdueNumbers = Object.entries(gaps)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([n]) => parseInt(n));

            return `Du bist ein KI-Experte f√ºr Lottozahlen-Analyse. Analysiere folgende Daten f√ºr das deutsche Lotto 6 aus 49:

AKTUELLE STATISTIKEN:
- Gesamte Ziehungen: ${lottoData.length}
- Letzte Ziehung: ${recentDraws[0]?.date} - Zahlen: ${recentDraws[0]?.numbers.join(', ')} - Superzahl: ${recentDraws[0]?.superzahl}

H√ÑUFIGKEITSANALYSE:
- Hei√üeste Zahlen: ${hotNumbers.join(', ')}
- K√§lteste Zahlen: ${coldNumbers.join(', ')}
- √úberf√§llige Zahlen: ${overdueNumbers.join(', ')}

LETZTEN 5 ZIEHUNGEN:
${recentDraws.slice(0, 5).map(d => `${d.date}: ${d.numbers.join(', ')} | SZ: ${d.superzahl}`).join('\n')}

AUFGABE: Generiere 3 Lotto-Tipps. Antworte NUR im JSON-Format:
{
  "predictions": [
    {"numbers": [1,2,3,4,5,6], "superzahl": 5, "confidence": 75, "strategy": "Beschreibung"}
  ]
}`;
        }

        // Multi-KI Analyse
        async function analyzeWithMultiKI(lottoData, frequencyMap, superzahlMap) {
            const prompt = createAnalysisPrompt(lottoData, frequencyMap, superzahlMap);
            const activeProviders = multiKI.getActiveProviders();
            
            if (activeProviders.length === 0) {
                showToast('‚ö†Ô∏è Keine KI-APIs konfiguriert', '‚ö†Ô∏è');
                return generateLocalAIPredictions(
                    Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([n]) => parseInt(n)),
                    Object.entries(frequencyMap).sort((a, b) => a[1] - b[1]).slice(0, 10).map(([n]) => parseInt(n)),
                    [],
                    {}
                );
            }

            showToast(`ü§ñ ${activeProviders.length} KIs analysieren...`, 'üß†');
            updateMultiKIStatus('loading', activeProviders);

            const results = await multiKI.callAllProviders(prompt);
            const successCount = Object.keys(results).length;

            if (successCount === 0) {
                showToast('‚ö†Ô∏è KI-APIs nicht erreichbar, nutze lokales Modell', '‚ö†Ô∏è');
                return generateLocalAIPredictions(
                    Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([n]) => parseInt(n)),
                    Object.entries(frequencyMap).sort((a, b) => a[1] - b[1]).slice(0, 10).map(([n]) => parseInt(n)),
                    [],
                    {}
                );
            }

            showToast(`‚úÖ ${successCount} KIs haben geantwortet!`, 'üéØ');
            updateMultiKIStatus('success', Object.keys(results));

            const ensemble = multiKI.combineResults(results, frequencyMap);
            
            return {
                analysis: ensemble.analysis,
                predictions: ensemble.predictions,
                insights: {
                    trend: `${successCount} KI-Systeme haben zusammengearbeitet`,
                    recommendation: 'Ensemble-Tipps haben die h√∂chste Konfidenz',
                    warning: 'Lotto bleibt Zufall - KI erh√∂ht nur minimal die Chancen'
                },
                multiKI: true,
                votingStats: ensemble.votingStats
            };
        }

        function updateMultiKIStatus(status, providers) {
            const statusEl = document.getElementById('multiKIStatus');
            if (!statusEl) return;

            if (status === 'loading') {
                statusEl.innerHTML = providers.map(p => 
                    `<span class="ki-chip loading">${multiKI.providers[p]?.icon || 'ü§ñ'} ${multiKI.providers[p]?.name || p}</span>`
                ).join('');
            } else if (status === 'success') {
                statusEl.innerHTML = providers.map(p => 
                    `<span class="ki-chip success">${multiKI.providers[p]?.icon || 'ü§ñ'} ${multiKI.providers[p]?.name || p} ‚úì</span>`
                ).join('');
            }
        }

        // Echte KI-Analyse mit Claude API
        async function analyzeWithRealAI(lottoData, frequencyMap, superzahlMap) {
            // Nutze Multi-KI wenn APIs konfiguriert sind
            const activeProviders = multiKI.getActiveProviders();
            
            if (activeProviders.length > 1) {
                return await analyzeWithMultiKI(lottoData, frequencyMap, superzahlMap);
            }

            // Fallback auf nur Claude oder lokales Modell
            const prompt = createAnalysisPrompt(lottoData, frequencyMap, superzahlMap);
            
            try {
                showToast('ü§ñ KI analysiert...', 'üß†');
                
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 4000,
                        messages: [{ role: "user", content: prompt }]
                    })
                });

                if (!response.ok) throw new Error(`API Fehler: ${response.status}`);

                const data = await response.json();
                const aiResponse = data.content[0].text;
                
                const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    kiAgent.lastAnalysis = parsed;
                    return parsed;
                }
                
                throw new Error('Konnte KI-Antwort nicht parsen');
                
            } catch (error) {
                console.log('KI-API nicht verf√ºgbar, nutze lokales Modell:', error.message);
                const sortedFreq = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]);
                return generateLocalAIPredictions(
                    sortedFreq.slice(0, 10).map(([n]) => parseInt(n)),
                    sortedFreq.slice(-10).map(([n]) => parseInt(n)),
                    [],
                    {}
                );
            }
        }

        // Lokales KI-Modell als Fallback (Machine Learning Simulation)
        function generateLocalAIPredictions(hotNumbers, coldNumbers, overdueNumbers, gaps) {
            const bestStrategies = kiAgent.getBestStrategies();
            const predictions = [];
            
            // Analysiere Superzahl-Muster f√ºr lokale Vorhersagen
            const szAnalysis = szAnalyzer.predictBestSuperzahl(lottoData);
            const rankedSuperzahlen = szAnalysis.all;
            
            // Verschiedene ML-inspirierte Strategien
            const strategies = [
                {
                    name: 'Neuronales Netz: Hot-Cold Balance',
                    fn: () => {
                        const nums = [];
                        nums.push(...hotNumbers.slice(0, 3));
                        nums.push(...coldNumbers.filter(n => !nums.includes(n)).slice(0, 2));
                        while (nums.length < 6) {
                            const r = Math.floor(Math.random() * 49) + 1;
                            if (!nums.includes(r)) nums.push(r);
                        }
                        return nums.sort((a, b) => a - b);
                    }
                },
                {
                    name: 'Gradient Descent: Optimierte H√§ufigkeit',
                    fn: () => {
                        const scores = {};
                        for (let i = 1; i <= 49; i++) {
                            const freqScore = (frequencyMap[i] || 0) / Math.max(...Object.values(frequencyMap));
                            scores[i] = freqScore + Math.random() * 0.3;
                        }
                        return Object.entries(scores)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 6)
                            .map(([n]) => parseInt(n))
                            .sort((a, b) => a - b);
                    }
                },
                {
                    name: 'Random Forest: Ensemble-Methode',
                    fn: () => {
                        const votes = {};
                        for (let tree = 0; tree < 10; tree++) {
                            const pool = tree % 2 === 0 ? hotNumbers : coldNumbers;
                            pool.slice(0, 5).forEach(n => votes[n] = (votes[n] || 0) + 1);
                        }
                        return Object.entries(votes)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 6)
                            .map(([n]) => parseInt(n))
                            .sort((a, b) => a - b);
                    }
                },
                {
                    name: 'LSTM: Sequenz-Vorhersage',
                    fn: () => {
                        const recent = lottoData.slice(0, 20);
                        const freq = {};
                        recent.forEach((draw, i) => {
                            const weight = 1 - (i / 20) * 0.5;
                            draw.numbers.forEach(n => {
                                freq[n] = (freq[n] || 0) + weight;
                            });
                        });
                        return Object.entries(freq)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 6)
                            .map(([n]) => parseInt(n))
                            .sort((a, b) => a - b);
                    }
                },
                {
                    name: 'Bayesian: Wahrscheinlichkeitsmaximierung',
                    fn: () => {
                        const nums = [];
                        while (nums.length < 6) {
                            const weighted = hotNumbers.concat(coldNumbers);
                            const pick = weighted[Math.floor(Math.random() * weighted.length)];
                            if (!nums.includes(pick)) nums.push(pick);
                        }
                        return nums.sort((a, b) => a - b);
                    }
                },
                {
                    name: 'K-Means: Cluster-Analyse',
                    fn: () => {
                        const clusters = [[1,10], [11,20], [21,30], [31,40], [41,49]];
                        const nums = [];
                        clusters.forEach(([min, max]) => {
                            const n = Math.floor(Math.random() * (max - min + 1)) + min;
                            nums.push(n);
                        });
                        while (nums.length < 6) {
                            nums.push(Math.floor(Math.random() * 49) + 1);
                        }
                        return [...new Set(nums)].slice(0, 6).sort((a, b) => a - b);
                    }
                },
                {
                    name: 'Reinforcement Learning: Belohnungsoptimiert',
                    fn: () => {
                        const bestStrat = bestStrategies[0];
                        if (bestStrat && bestStrat.avgMatches > 1) {
                            return hotNumbers.slice(0, 6).sort((a, b) => a - b);
                        }
                        return coldNumbers.slice(0, 6).sort((a, b) => a - b);
                    }
                },
                {
                    name: 'GAN: Generative Zahlensequenz',
                    fn: () => {
                        if (lottoData.length > 0) {
                            const template = lottoData[Math.floor(Math.random() * Math.min(20, lottoData.length))].numbers;
                            return template.map(n => {
                                const delta = Math.floor(Math.random() * 5) - 2;
                                return Math.max(1, Math.min(49, n + delta));
                            }).sort((a, b) => a - b);
                        }
                        return [3, 12, 25, 33, 41, 47];
                    }
                },
                {
                    name: 'Transformer: Attention-Mechanismus',
                    fn: () => {
                        const attention = {};
                        for (let i = 1; i <= 49; i++) {
                            const inRecent = lottoData.slice(0, 10).filter(d => d.numbers.includes(i)).length;
                            attention[i] = inRecent * 2 + Math.random();
                        }
                        return Object.entries(attention)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 6)
                            .map(([n]) => parseInt(n))
                            .sort((a, b) => a - b);
                    }
                },
                {
                    name: 'Hybrid: Multi-Model Ensemble',
                    fn: () => {
                        const allNums = [...hotNumbers.slice(0, 4), ...coldNumbers.slice(0, 4)];
                        const unique = [...new Set(allNums)];
                        while (unique.length < 6) {
                            unique.push(Math.floor(Math.random() * 49) + 1);
                        }
                        return unique.slice(0, 6).sort((a, b) => a - b);
                    }
                }
            ];

            strategies.forEach((strat, i) => {
                const numbers = strat.fn();
                // Nutze die statistisch beste Superzahl (rotierend durch Top 5)
                const szLength = rankedSuperzahlen.length || 1;
                const superzahl = rankedSuperzahlen[i % Math.min(5, szLength)]?.number ?? Math.floor(Math.random() * 10);
                const confidence = 45 + Math.random() * 40;
                
                predictions.push({
                    numbers: numbers,
                    superzahl: superzahl,
                    confidence: confidence.toFixed(1),
                    strategy: strat.name,
                    reasoning: `Lokales ML-Modell + Superzahl ${superzahl} (${rankedSuperzahlen.find(s => s.number === superzahl)?.probability || '?'}% Wahrscheinlichkeit)`,
                    source: 'local',
                    superzahlOptimized: true
                });
            });

            return {
                analysis: `Lokales KI-System hat ${lottoData.length} Ziehungen analysiert. Optimale Superzahl: ${rankedSuperzahlen[0]?.number} (${rankedSuperzahlen[0]?.probability}%)`,
                predictions: predictions,
                insights: {
                    trend: `Zahlen ${hotNumbers.slice(0, 3).join(', ')} sind aktuell hei√ü`,
                    recommendation: 'Kombiniere hei√üe und √ºberf√§llige Zahlen',
                    warning: 'F√ºr bessere Ergebnisse: Konfiguriere externe KI-APIs!'
                },
                votingStats: {
                    superzahlAnalysis: {
                        best: rankedSuperzahlen[0],
                        top3: rankedSuperzahlen.slice(0, 3),
                        all: rankedSuperzahlen,
                        patterns: szAnalyzer.patterns,
                        nextDrawDay: szAnalysis.nextDrawDay
                    }
                }
            };
        }

        // Haupt-Vorhersagefunktion
        async function generatePredictions() {
            showLoader(true);
            
            try {
                const aiResult = await analyzeWithRealAI(lottoData, frequencyMap, superzahlMap);
                
                if (aiResult && aiResult.predictions) {
                    renderAIPredictions(aiResult);
                    updateKIStatus(true, aiResult);
                    kiAgent.lastAnalysis = aiResult;
                }
            } catch (error) {
                console.error('Prediction error:', error);
                const sortedFreq = Object.entries(frequencyMap).sort((a, b) => b[1] - a[1]);
                const fallbackResult = generateLocalAIPredictions(
                    sortedFreq.slice(0, 10).map(([n]) => parseInt(n)),
                    sortedFreq.slice(-10).map(([n]) => parseInt(n)),
                    [],
                    {}
                );
                renderAIPredictions(fallbackResult);
            }
            
            showLoader(false);
        }

        function renderAIPredictions(aiResult) {
            let html = '';
            
            // Superzahl-Analyse anzeigen (wenn vorhanden)
            if (aiResult.votingStats?.superzahlAnalysis) {
                const szA = aiResult.votingStats.superzahlAnalysis;
                html += `
                    <div class="superzahl-analysis-card">
                        <div class="sz-header">
                            <span class="sz-icon">‚≠ê</span>
                            <div>
                                <div class="sz-title">Optimale Superzahl-Analyse</div>
                                <div class="sz-subtitle">N√§chste Ziehung: ${szA.nextDrawDay}</div>
                            </div>
                        </div>
                        <div class="sz-best">
                            <div class="sz-best-number">${szA.best.number}</div>
                            <div class="sz-best-info">
                                <div class="sz-best-label">Beste Superzahl</div>
                                <div class="sz-best-prob">${szA.best.probability}% Wahrscheinlichkeit</div>
                            </div>
                        </div>
                        <div class="sz-alternatives">
                            <div class="sz-alt-title">Alternativen:</div>
                            <div class="sz-alt-list">
                                ${szA.top3.slice(1).map(s => `
                                    <span class="sz-alt-item">
                                        <span class="sz-alt-num">${s.number}</span>
                                        <span class="sz-alt-prob">${s.probability}%</span>
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Multi-KI Status anzeigen
            if (aiResult.multiKI && aiResult.votingStats) {
                html += `
                    <div class="ensemble-header">
                        <div class="ensemble-title">
                            <span>üèÜ</span> Multi-KI Ensemble Ergebnis
                        </div>
                        <div class="ensemble-stats">
                            ${aiResult.votingStats.providersUsed} KIs haben abgestimmt
                        </div>
                        <div id="multiKIStatus" class="multi-ki-chips"></div>
                    </div>
                `;
            }
            
            aiResult.predictions.forEach((pred, i) => {
                const colors = ['purple', 'teal', 'pink', 'gold'];
                const color = colors[i % colors.length];
                const isEnsemble = pred.isEnsemble;
                
                let ballsHTML = '';
                pred.numbers.forEach(num => {
                    ballsHTML += `<div class="lotto-ball small">${num}</div>`;
                });
                
                // Superzahl mit Highlight wenn optimiert
                const szOptimized = pred.superzahlOptimized || pred.isEnsemble;
                ballsHTML += `<div class="lotto-ball small superzahl ${szOptimized ? 'optimized' : ''}" title="${szOptimized ? 'KI-optimierte Superzahl' : ''}">${pred.superzahl}</div>`;
                
                html += `
                    <div class="prediction-card ${isEnsemble ? 'ensemble-card' : ''}" style="animation-delay: ${i * 0.1}s">
                        <div class="prediction-header">
                            <span class="prediction-rank">${isEnsemble ? 'üèÜ' : 'ü§ñ'} KI-Tipp #${i + 1}</span>
                            <span class="prediction-confidence">${pred.confidence}% Konfidenz</span>
                        </div>
                        <div class="lotto-balls" style="justify-content: flex-start; margin: 15px 0;">
                            ${ballsHTML}
                        </div>
                        <div class="progress-container">
                            <div class="progress-label">
                                <span>üß† ${pred.strategy}</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill ${color}" style="width: ${pred.confidence}%"></div>
                            </div>
                            ${pred.reasoning ? `<p style="font-size: 12px; color: var(--text-secondary); margin-top: 10px;">${pred.reasoning}</p>` : ''}
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('predictionsContainer').innerHTML = html;
        }

        async function updateKIStatus(isOnline, aiResult) {
            const aiMessage = document.getElementById('aiMessage');
            const accuracy = kiAgent.getAccuracyRate();
            const providerRankings = multiKI.getProviderRankings();
            const activeProviders = multiKI.getActiveProviders();
            const storageStats = await kiAgent.getStorageStats();
            const szAccuracy = szAnalyzer.getAccuracy();
            
            let message = `
                <strong>ü§ñ Multi-KI-Agent Status: ${isOnline ? '‚úÖ AKTIV' : '‚ö†Ô∏è LOKALER MODUS'}</strong><br><br>
                <strong>üìä Analyse:</strong> ${aiResult.analysis}<br><br>
                
                <strong>üíæ Speicherung (IndexedDB):</strong><br>
                ‚Ä¢ Lern-Eintr√§ge: ${storageStats.learningEntries}<br>
                ‚Ä¢ Gespeicherte Vorhersagen: ${storageStats.predictions}<br>
                ‚Ä¢ Superzahl-Historie: ${storageStats.superzahlHistory}<br><br>
                
                <strong>üîå Aktive KI-Systeme:</strong> ${activeProviders.length}<br>
                ${activeProviders.map(p => `‚Ä¢ ${multiKI.providers[p]?.icon || 'ü§ñ'} ${multiKI.providers[p]?.name || p}`).join('<br>')}<br><br>
                
                <strong>üéØ Lernstatistik:</strong><br>
                ‚Ä¢ Zahlen-Vorhersagen: ${kiAgent.predictionAccuracy.total} (${accuracy}% Erfolg bei 3+)<br>
                ‚Ä¢ Superzahl-Vorhersagen: ${szAccuracy.total} (${szAccuracy.rate}% korrekt)<br>
            `;
            
            if (providerRankings.length > 0) {
                message += `<br><strong>üèÜ KI-Ranking:</strong><br>`;
                message += providerRankings.slice(0, 3).map((r, i) => 
                    `${i + 1}. ${r.icon} ${r.name}: ${r.accuracy}% Zahlen | ${r.szAccuracy}% SZ`
                ).join('<br>');
            }
            
            if (aiResult.insights) {
                message += `<br><br><strong>üí° Insights:</strong><br>
                    ‚Ä¢ ${aiResult.insights.trend}<br>
                    ‚Ä¢ ${aiResult.insights.recommendation}`;
            }
            
            message += `<br><br><em>üíæ Alle Daten werden permanent in IndexedDB gespeichert und gehen nicht verloren!</em>`;
            
            aiMessage.innerHTML = message;
        }

        async function updateAIMessage() {
            const activeProviders = multiKI.getActiveProviders();
            const storageStats = await kiAgent.getStorageStats();
            
            document.getElementById('aiMessage').innerHTML = `
                <strong>ü§ñ Multi-KI-System bereit</strong><br><br>
                
                <strong>üíæ Speicherung:</strong><br>
                ‚Ä¢ ${storageStats.learningEntries} Lern-Eintr√§ge gespeichert<br>
                ‚Ä¢ ${storageStats.predictions} Vorhersagen archiviert<br>
                ‚Ä¢ Daten bleiben permanent erhalten!<br><br>
                
                <strong>üîå Aktive KI-Provider:</strong> ${activeProviders.length}<br>
                ${activeProviders.map(p => `‚Ä¢ ${multiKI.providers[p]?.icon} ${multiKI.providers[p]?.name}`).join('<br>')}<br><br>
                
                <strong>Unterst√ºtzte KI-Systeme:</strong><br>
                ‚Ä¢ üîÆ Google Gemini - Kostenloses Tier<br>
                ‚Ä¢ ‚ö° Groq - Ultraschnelle Inferenz<br>
                ‚Ä¢ ü§ó HuggingFace - Open Source<br>
                ‚Ä¢ üåê OpenRouter - 50+ Modelle<br>
                ‚Ä¢ üöÄ Together AI - $25 Gratis<br>
                ‚Ä¢ üß† DeepSeek - Komplett kostenlos<br>
                ‚Ä¢ ü§ñ Claude - Premium KI<br><br>
                <em>Klicke auf ‚öôÔ∏è um API-Keys zu konfigurieren!</em>
            `;
        }

        // Alte Funktionen wurden durch KI-Agent ersetzt (siehe oben)

        // Render API Keys Liste im Settings Modal
        function renderApiKeysList() {
            const container = document.getElementById('apiKeysList');
            const providers = multiKI.providers;
            
            const apiInfos = {
                gemini: {
                    getKeyUrl: 'https://aistudio.google.com/apikey',
                    placeholder: 'AIzaSy...'
                },
                groq: {
                    getKeyUrl: 'https://console.groq.com/keys',
                    placeholder: 'gsk_...'
                },
                huggingface: {
                    getKeyUrl: 'https://huggingface.co/settings/tokens',
                    placeholder: 'hf_...'
                },
                openrouter: {
                    getKeyUrl: 'https://openrouter.ai/keys',
                    placeholder: 'sk-or-...'
                },
                together: {
                    getKeyUrl: 'https://api.together.xyz/settings/api-keys',
                    placeholder: 'tog_...'
                },
                deepseek: {
                    getKeyUrl: 'https://platform.deepseek.com/api_keys',
                    placeholder: 'sk-...'
                }
            };

            let html = '';
            
            Object.entries(providers).forEach(([key, provider]) => {
                if (key === 'claude') return; // Claude ist automatisch
                
                const currentKey = multiKI.apiKeys[key] || '';
                const isActive = !!currentKey;
                const info = apiInfos[key] || { getKeyUrl: '#', placeholder: 'API Key eingeben...' };
                
                html += `
                    <div class="api-key-item">
                        <div class="api-key-header">
                            <div class="api-key-name">
                                <span class="icon">${provider.icon}</span>
                                ${provider.name}
                            </div>
                            <span class="api-key-status ${isActive ? 'active' : 'inactive'}">
                                ${isActive ? '‚úì Aktiv' : 'Nicht konfiguriert'}
                            </span>
                        </div>
                        <div class="api-key-description">
                            ${provider.description} ‚Ä¢ ${provider.free ? 'üÜì Kostenlos' : 'üí∞ Kostenpflichtig'}
                        </div>
                        <div class="api-key-input">
                            <input type="password" 
                                   id="apikey-${key}" 
                                   value="${currentKey}"
                                   placeholder="${info.placeholder}">
                            <button class="btn-save-key" onclick="saveApiKey('${key}')">
                                Speichern
                            </button>
                        </div>
                        <a href="${info.getKeyUrl}" target="_blank" class="api-link">
                            üîë API-Key kostenlos holen ‚Üí
                        </a>
                    </div>
                `;
            });

            // Claude Info (automatisch)
            html += `
                <div class="api-key-item" style="background: rgba(108, 92, 231, 0.1); border: 1px solid rgba(108, 92, 231, 0.2);">
                    <div class="api-key-header">
                        <div class="api-key-name">
                            <span class="icon">ü§ñ</span>
                            Claude (Anthropic)
                        </div>
                        <span class="api-key-status active">‚úì Automatisch</span>
                    </div>
                    <div class="api-key-description">
                        Premium KI von Anthropic ‚Ä¢ In dieser App automatisch integriert
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Speichert einen API-Key
        function saveApiKey(provider) {
            const input = document.getElementById(`apikey-${provider}`);
            const key = input.value.trim();
            
            multiKI.saveApiKey(provider, key);
            
            if (key) {
                showToast(`‚úÖ ${multiKI.providers[provider].name} API-Key gespeichert!`, 'üîë');
            } else {
                showToast(`üóëÔ∏è ${multiKI.providers[provider].name} API-Key entfernt`, 'üîë');
            }
            
            renderApiKeysList();
            updateAIMessage();
        }

        // Expose to global scope for onclick
        window.saveApiKey = saveApiKey;

        // ========================================
        // DEEP ANALYSIS
        // ========================================

        function runDeepAnalysis() {
            const resultsContainer = document.getElementById('analysisResults');
            const messageContainer = document.getElementById('deepAnalysisMessage');
            
            messageContainer.innerHTML = 'ü§ñ <strong>KI-Agent f√ºhrt Deep-Analyse durch...</strong> Mehrere ML-Modelle werden parallel ausgef√ºhrt.';
            resultsContainer.innerHTML = '<div class="loader active"><div class="spinner"></div></div>';
            
            setTimeout(async () => {
                const analysis = performDeepAnalysis();
                
                // Versuche Claude API f√ºr zus√§tzliche Insights
                try {
                    const aiInsights = await getDeepAIInsights(analysis);
                    if (aiInsights) {
                        analysis.aiInsights = aiInsights;
                    }
                } catch (e) {
                    console.log('Deep AI insights not available');
                }
                
                renderDeepAnalysis(analysis);
                messageContainer.innerHTML = '‚úÖ <strong>Deep-Analyse abgeschlossen!</strong> KI-Agent hat alle Modelle ausgewertet.';
            }, 2500);
        }

        async function getDeepAIInsights(analysis) {
            const prompt = `
Analysiere diese Lotto-Statistiken und gib pr√§zise Insights:

TOP ZAHLENPAARE: ${analysis.topPairs.slice(0, 5).map(([p, c]) => `${p} (${c}x)`).join(', ')}
DURCHSCHNITTSSUMME: ${analysis.avgSum}
KONSEKUTIVE ZAHLEN: ${analysis.consecutiveNumbers}
TRENDS: ${analysis.trends.slice(0, 5).map(t => `${t.number} ${t.trend}`).join(', ')}

Antworte NUR mit JSON:
{
  "pattern": "Erkanntes Hauptmuster",
  "prediction_hint": "Konkrete Empfehlung",
  "confidence": 75
}`;

            try {
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 500,
                        messages: [{ role: "user", content: prompt }]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const text = data.content[0].text;
                    const json = text.match(/\{[\s\S]*\}/);
                    if (json) return JSON.parse(json[0]);
                }
            } catch (e) {}
            
            return null;
        }

        function performDeepAnalysis() {
            // Analyze patterns in the data
            const analysis = {
                numberPairs: {},
                numberTriples: {},
                consecutiveNumbers: 0,
                sumDistribution: [],
                rangeDistribution: { low: 0, mid: 0, high: 0 },
                weekdayAnalysis: { mittwoch: {}, samstag: {} },
                trends: []
            };

            // Analyze last 500 draws
            const recentDraws = lottoData.slice(0, 500);
            
            recentDraws.forEach(draw => {
                const nums = draw.numbers;
                
                // Pair analysis
                for (let i = 0; i < nums.length; i++) {
                    for (let j = i + 1; j < nums.length; j++) {
                        const pair = `${nums[i]}-${nums[j]}`;
                        analysis.numberPairs[pair] = (analysis.numberPairs[pair] || 0) + 1;
                    }
                }
                
                // Check for consecutive numbers
                for (let i = 0; i < nums.length - 1; i++) {
                    if (nums[i + 1] - nums[i] === 1) {
                        analysis.consecutiveNumbers++;
                    }
                }
                
                // Sum distribution
                const sum = nums.reduce((a, b) => a + b, 0);
                analysis.sumDistribution.push(sum);
                
                // Range distribution
                nums.forEach(n => {
                    if (n <= 16) analysis.rangeDistribution.low++;
                    else if (n <= 33) analysis.rangeDistribution.mid++;
                    else analysis.rangeDistribution.high++;
                });
            });

            // Find top pairs
            analysis.topPairs = Object.entries(analysis.numberPairs)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            // Calculate average sum
            analysis.avgSum = Math.round(analysis.sumDistribution.reduce((a, b) => a + b, 0) / analysis.sumDistribution.length);
            
            // Trend analysis
            const recent100 = lottoData.slice(0, 100);
            const older100 = lottoData.slice(100, 200);
            
            for (let i = 1; i <= 49; i++) {
                const recentCount = recent100.filter(d => d.numbers.includes(i)).length;
                const olderCount = older100.filter(d => d.numbers.includes(i)).length;
                
                if (recentCount > olderCount * 1.3) {
                    analysis.trends.push({ number: i, trend: 'steigend', change: ((recentCount / olderCount - 1) * 100).toFixed(0) });
                } else if (recentCount < olderCount * 0.7) {
                    analysis.trends.push({ number: i, trend: 'fallend', change: ((1 - recentCount / olderCount) * 100).toFixed(0) });
                }
            }

            return analysis;
        }

        function renderDeepAnalysis(analysis) {
            const resultsContainer = document.getElementById('analysisResults');
            
            let pairsHTML = '';
            analysis.topPairs.forEach(([pair, count], i) => {
                pairsHTML += `
                    <div style="display: flex; justify-content: space-between; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px; margin-bottom: 8px;">
                        <span style="font-family: 'Space Mono', monospace; color: var(--secondary);">${pair}</span>
                        <span style="color: var(--gold);">${count}x zusammen gezogen</span>
                    </div>
                `;
            });

            let trendsHTML = '';
            analysis.trends.slice(0, 8).forEach(trend => {
                const isUp = trend.trend === 'steigend';
                trendsHTML += `
                    <div style="display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: ${isUp ? 'rgba(0,184,148,0.1)' : 'rgba(225,112,85,0.1)'}; border-radius: 20px; margin: 5px;">
                        <span style="font-weight: 700;">${trend.number}</span>
                        <span style="color: ${isUp ? 'var(--success)' : 'var(--warning)'};">${isUp ? '‚Üë' : '‚Üì'} ${trend.change}%</span>
                    </div>
                `;
            });

            // KI-Agent Insights Card (wenn vorhanden)
            let aiInsightsHTML = '';
            if (analysis.aiInsights) {
                aiInsightsHTML = `
                    <div class="card" style="background: linear-gradient(135deg, rgba(108, 92, 231, 0.15) 0%, rgba(0, 206, 201, 0.15) 100%); border: 1px solid rgba(108, 92, 231, 0.3);">
                        <div class="card-title" style="margin-bottom: 20px;">
                            <span class="icon purple">ü§ñ</span>
                            KI-Agent Deep Insights
                        </div>
                        <div style="padding: 20px; background: rgba(0,0,0,0.2); border-radius: 16px;">
                            <div style="margin-bottom: 15px;">
                                <strong style="color: var(--secondary);">üîç Erkanntes Muster:</strong><br>
                                <span style="color: var(--text-primary);">${analysis.aiInsights.pattern}</span>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <strong style="color: var(--gold);">üí° KI-Empfehlung:</strong><br>
                                <span style="color: var(--text-primary);">${analysis.aiInsights.prediction_hint}</span>
                            </div>
                            <div>
                                <strong style="color: var(--accent);">üéØ Konfidenz:</strong>
                                <span style="font-family: 'Space Mono', monospace; color: var(--gold);">${analysis.aiInsights.confidence}%</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // KI-Agent Learning Status
            const learningHTML = `
                <div class="card" style="background: linear-gradient(135deg, rgba(0, 184, 148, 0.1) 0%, rgba(0, 206, 201, 0.1) 100%);">
                    <div class="card-title" style="margin-bottom: 20px;">
                        <span class="icon teal">üß†</span>
                        KI-Agent Lernstatus
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-icon gold">üìä</div>
                            <div>
                                <div class="stat-value">${kiAgent.predictionAccuracy.total}</div>
                                <div class="stat-label">Analysierte Vorhersagen</div>
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon purple">üéØ</div>
                            <div>
                                <div class="stat-value">${kiAgent.getAccuracyRate()}%</div>
                                <div class="stat-label">Erfolgsquote (3+ Treffer)</div>
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon teal">üîÑ</div>
                            <div>
                                <div class="stat-value">v${kiAgent.modelVersion}</div>
                                <div class="stat-label">Model Version</div>
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon pink">üìà</div>
                            <div>
                                <div class="stat-value">${kiAgent.learningHistory.length}</div>
                                <div class="stat-label">Lerneintr√§ge</div>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 12px;">
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 0;">
                            ü§ñ <strong>Kontinuierliches Lernen aktiv:</strong> Der KI-Agent analysiert jede neue Ziehung, 
                            vergleicht mit seinen Vorhersagen und passt die Algorithmen entsprechend an. 
                            Je mehr Daten, desto besser werden die Vorhersagen!
                        </p>
                    </div>
                </div>
            `;

            resultsContainer.innerHTML = `
                ${aiInsightsHTML}
                
                ${learningHTML}

                <div class="card" style="margin-top: 0;">
                    <div class="card-title" style="margin-bottom: 20px;">
                        <span class="icon teal">üî¢</span>
                        Zahlenpaare (h√§ufigste Kombinationen)
                    </div>
                    ${pairsHTML}
                </div>

                <div class="card">
                    <div class="card-title" style="margin-bottom: 20px;">
                        <span class="icon pink">üìä</span>
                        Statistische Erkenntnisse
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-icon purple">Œ£</div>
                            <div>
                                <div class="stat-value">${analysis.avgSum}</div>
                                <div class="stat-label">Durchschnittliche Summe der 6 Zahlen</div>
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-icon teal">üîó</div>
                            <div>
                                <div class="stat-value">${analysis.consecutiveNumbers}</div>
                                <div class="stat-label">Aufeinanderfolgende Zahlen (letzte 500)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title" style="margin-bottom: 20px;">
                        <span class="icon gold">üìà</span>
                        Trend-Analyse (letzte 100 vs. vorherige 100)
                    </div>
                    <div>
                        ${trendsHTML || '<p style="color: var(--text-secondary);">Keine signifikanten Trends erkannt.</p>'}
                    </div>
                </div>

                <div class="card">
                    <div class="card-title" style="margin-bottom: 20px;">
                        <span class="icon purple">üìç</span>
                        Zahlenbereich-Verteilung
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                        <div style="text-align: center; padding: 20px; background: rgba(108,92,231,0.1); border-radius: 16px;">
                            <div style="font-size: 28px; font-weight: 700; color: var(--primary);">${((analysis.rangeDistribution.low / (analysis.rangeDistribution.low + analysis.rangeDistribution.mid + analysis.rangeDistribution.high)) * 100).toFixed(1)}%</div>
                            <div style="color: var(--text-secondary); font-size: 13px;">Niedrig (1-16)</div>
                        </div>
                        <div style="text-align: center; padding: 20px; background: rgba(0,206,201,0.1); border-radius: 16px;">
                            <div style="font-size: 28px; font-weight: 700; color: var(--secondary);">${((analysis.rangeDistribution.mid / (analysis.rangeDistribution.low + analysis.rangeDistribution.mid + analysis.rangeDistribution.high)) * 100).toFixed(1)}%</div>
                            <div style="color: var(--text-secondary); font-size: 13px;">Mittel (17-33)</div>
                        </div>
                        <div style="text-align: center; padding: 20px; background: rgba(253,121,168,0.1); border-radius: 16px;">
                            <div style="font-size: 28px; font-weight: 700; color: var(--accent);">${((analysis.rangeDistribution.high / (analysis.rangeDistribution.low + analysis.rangeDistribution.mid + analysis.rangeDistribution.high)) * 100).toFixed(1)}%</div>
                            <div style="color: var(--text-secondary); font-size: 13px;">Hoch (34-49)</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================


        // =====================================================
        // GITHUB VORHERSAGEN LADEN (f√ºr automatisierte Updates)
        // =====================================================
        const GITHUB_USER = 'micki79';
        const GITHUB_REPO = 'lotto-genius';
        const GITHUB_DATA_URL = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/main/data`;
        
        async function loadGitHubPredictions() {
            try {
                const response = await fetch(`${GITHUB_DATA_URL}/predictions.json?t=${Date.now()}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.predictions && data.predictions.length > 0) {
                        console.log('ü§ñ GitHub-Vorhersagen geladen:', data.predictions.length);
                        showToast(`ü§ñ ${data.predictions.length} Auto-KI-Tipps geladen!`, 'üçÄ');
                        localStorage.setItem('github_predictions', JSON.stringify(data));
                        return data;
                    }
                }
            } catch (e) {
                console.log('GitHub-Vorhersagen nicht verf√ºgbar');
            }
            return null;
        }
        
        async function loadGitHubStats() {
            try {
                const [learning, providers] = await Promise.all([
                    fetch(`${GITHUB_DATA_URL}/learning.json?t=${Date.now()}`).then(r => r.ok ? r.json() : null),
                    fetch(`${GITHUB_DATA_URL}/provider_scores.json?t=${Date.now()}`).then(r => r.ok ? r.json() : null)
                ]);
                if (learning || providers) {
                    localStorage.setItem('github_learning', JSON.stringify(learning || {}));
                    localStorage.setItem('github_providers', JSON.stringify(providers || {}));
                }
                return { learning, providers };
            } catch (e) {}
            return null;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Lade GitHub-Vorhersagen im Hintergrund
            loadGitHubPredictions();
            loadGitHubStats();

            // Initialisiere Datenbank
            try {
                await lottoDB.init();
                console.log('üì¶ IndexedDB bereit');
            } catch (e) {
                console.log('IndexedDB nicht verf√ºgbar, nutze localStorage');
            }

            // Initialisiere KI-Agenten
            await kiAgent.init();
            await multiKI.init();
            await szAnalyzer.loadHistory();
            
            // Lade Lotto-Daten
            fetchLottoData();

            // Tab navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-panel`).classList.add('active');
                });
            });

            // Generate new predictions - handled in auto-refresh section below

            // Refresh data
            document.getElementById('refreshData').addEventListener('click', () => {
                fetchLottoData();
            });

            // Load more history
            document.getElementById('loadMoreHistory').addEventListener('click', () => {
                updateHistory(true);
            });

            // Deep analysis
            document.getElementById('startDeepAnalysis').addEventListener('click', () => {
                runDeepAnalysis();
            });

            // Settings Modal
            document.getElementById('settingsBtn').addEventListener('click', () => {
                renderApiKeysList();
                document.getElementById('settingsModal').classList.add('show');
            });

            document.getElementById('closeModal').addEventListener('click', () => {
                document.getElementById('settingsModal').classList.remove('show');
            });

            document.getElementById('settingsModal').addEventListener('click', (e) => {
                if (e.target.id === 'settingsModal') {
                    document.getElementById('settingsModal').classList.remove('show');
                }
            });

            // PWA Install
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                document.getElementById('installBanner').classList.add('show');
            });

            document.getElementById('installBtn').addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const result = await deferredPrompt.userChoice;
                    if (result.outcome === 'accepted') {
                        showToast('App wird installiert!', 'üì±');
                    }
                    deferredPrompt = null;
                    document.getElementById('installBanner').classList.remove('show');
                }
            });

            document.getElementById('closeBanner').addEventListener('click', () => {
                document.getElementById('installBanner').classList.remove('show');
            });

            // Auto-refresh data weekly and learn from new draws
            setInterval(() => {
                const now = new Date();
                const day = now.getDay();
                const hour = now.getHours();
                
                // Refresh after Wednesday 19:00 or Saturday 20:00
                if ((day === 3 && hour === 19) || (day === 6 && hour === 20)) {
                    fetchLottoData().then(() => {
                        // Check if we have previous predictions to learn from
                        const lastPredictions = localStorage.getItem('last_predictions');
                        if (lastPredictions && lottoData.length > 0) {
                            const predictions = JSON.parse(lastPredictions);
                            const actualNumbers = [...lottoData[0].numbers, lottoData[0].superzahl];
                            kiAgent.learnFromPastPredictions(actualNumbers, predictions);
                            showToast('üß† KI hat aus neuer Ziehung gelernt!', '‚úÖ');
                        }
                    });
                }
            }, 60 * 60 * 1000); // Check every hour

            // Generate predictions button
            document.getElementById('generatePredictions').addEventListener('click', async () => {
                await generatePredictions();
                showToast('ü§ñ Neue KI-Tipps generiert!', 'üîÆ');
                
                // Save for learning
                if (kiAgent.lastAnalysis && kiAgent.lastAnalysis.predictions) {
                    localStorage.setItem('last_predictions', JSON.stringify(kiAgent.lastAnalysis.predictions));
                }
            });
        });

        // ========================================
        // SERVICE WORKER REGISTRATION
        // ========================================

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered'))
                    .catch(err => console.log('SW registration failed'));
            });
        }
    </script>
</body>
</html>
